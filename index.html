<!doctype html>
<html lang="ar" dir="rtl">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,user-scalable=no" />
  <title>Ø­Ø§Ù…ÙŠ Ø§Ù„Ù…Ø¯Ø®Ù„ â€” Ù†Ø³Ø®Ø© Ø§Ù„Ù…ØªØ¬Ø± Ø§Ù„Ø¯Ø§Ø¦Ù…</title>
  <style>
    :root{--bg:#061026;--panel:#0f1724;--accent:#ffd166;--danger:#ef476f;--muted:#94a3b8}
html,body {
  height: 100%;
  margin: 0;
  font-family: "Tahoma", Arial, sans-serif;
  background: radial-gradient(circle at center, #0a0f2b 0%, #010511 100%);
  color: #fff;
  overflow: hidden;
}    #game-wrap{max-width:1200px;margin:18px auto;padding:12px;background:linear-gradient(180deg,rgba(255,255,255,0.02),rgba(255,255,255,0.01));border-radius:12px;box-shadow:0 6px 30px rgba(2,6,23,0.6);display:flex;flex-direction:column;height:calc(100vh - 36px)}
    header{display:flex;justify-content:space-between;align-items:center;padding:6px 12px;flex-shrink:0}
    h1{font-size:18px;margin:0}
    .controls{font-size:13px;color:var(--muted)}
    #game{display:block;flex-grow:1;background:#081026;border-radius:8px}
    footer{padding:8px 12px;color:var(--muted);font-size:13px;flex-shrink:0}
    .btn{background:var(--panel);border:none;color:#fff;padding:8px 10px;border-radius:8px;cursor:pointer;transition:background 0.2s}
    .btn:hover{background:#1a2536}
    .small{font-size:13px;padding:6px 8px}
    .pill{background:rgba(255,255,255,0.03);padding:6px 10px;border-radius:999px}
    #overlay{position:fixed;left:0;top:0;width:100%;height:100%;display:flex;align-items:center;justify-content:center;pointer-events:none;z-index:999}
    .menu{pointer-events:auto;background:linear-gradient(180deg,rgba(2,6,23,0.9),rgba(2,6,23,0.95));padding:18px;border-radius:12px;box-shadow:0 8px 30px rgba(0,0,0,0.6);min-width:320px;text-align:center;max-width:90%;max-height:90%;overflow-y:auto}
    .row{display:flex;gap:8px;align-items:center;justify-content:center;margin-bottom:8px}
    label{font-size:13px}
    input[type=range]{width:140px}
    .muted{color:var(--muted)}
    .upgrade-option{display:block;margin:6px 0;padding:10px;background:#1a2536;border:2px solid transparent;border-radius:8px;cursor:pointer;transition:background 0.2s, border-color 0.2s}
    .upgrade-option:hover{background:#2a3b50;border-color:var(--accent)}
    .store-item {
        display: flex;
        justify-content: space-between;
        align-items: center;
        padding: 10px;
        margin-bottom: 8px;
        background: #1a2536;
        border-radius: 8px;
    }
    .store-item-info {
        text-align: right;
        flex-grow: 1;
        padding-right: 10px;
    }
    .store-item-title {
        font-weight: bold;
        color: var(--accent);
    }
    .buy-btn {
        background: var(--accent);
        color: var(--panel);
        font-weight: bold;
        padding: 8px 12px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: opacity 0.2s;
        flex-shrink: 0;
        margin-right: 5px; /* Ù…Ø³Ø§ÙØ© Ø¨ÙŠÙ† Ø²Ø± Ø§Ù„Ø´Ø±Ø§Ø¡ ÙˆØ§Ù„Ø¨ÙŠØ¹ */
    }
    .btn {
  background: linear-gradient(180deg, #1e2742, #0d1326);
  border: 1px solid rgba(255,255,255,0.1);
  box-shadow: 0 4px 15px rgba(0,0,0,0.3);
}

.btn:hover {
  background: linear-gradient(180deg, #27355b, #101a33);
  box-shadow: 0 0 10px var(--accent);
}
    .buy-btn:disabled {
        background: var(--muted);
        cursor: default;
        opacity: 0.6;
    }
    /* Ø²Ø± Ø§Ù„Ø¨ÙŠØ¹ Ø§Ù„Ø¬Ø¯ÙŠØ¯ */
    .sell-btn {
        background: var(--danger);
        color: #fff;
        font-weight: bold;
        padding: 8px 12px;
        border: none;
        border-radius: 6px;
        cursor: pointer;
        transition: opacity 0.2s;
        flex-shrink: 0;
    }
    .sell-btn:disabled {
        background: var(--muted);
        cursor: default;
        opacity: 0.6;
    }
    @media(max-width:600px){#game-wrap{margin:8px;padding:8px}}

    /* Mobile Joystick Styles - Ù…Ø­Ø³Ù‘Ù† */
    .joystick-container {
      position: fixed;
      border-radius: 50%;
      background: rgba(255,255,255,0.08);
      border: 2px solid rgba(255,255,255,0.15);
      display: none;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 100;
      box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    }

    .joystick-container.active {
      pointer-events: auto;
      background: rgba(255,255,255,0.12);
    }

    #left-joystick { bottom: 30px; left: 30px; }
    #right-joystick { bottom: 30px; right: 30px; }

    .joystick-stick {
      border-radius: 50%;
      background: rgba(255,255,255,0.3);
      pointer-events: none;
      box-shadow: 0 2px 10px rgba(0,0,0,0.2);
      transition: transform 0.1s ease-out;
    }

    /* ØªØ­Ø³ÙŠÙ†Ø§Øª Ù„Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„ØµØºÙŠØ±Ø© */
    @media (max-width: 768px) {
      .joystick-container{
        display:flex;
        width: 20vw;
        height: 20vw;
        min-width: 90px;
        min-height: 90px;
        max-width: 120px;
        max-height: 120px;
      }
      
      .joystick-stick {
        width: 40%;
        height: 40%;
      }
      
      #left-joystick { bottom: 25px; left: 25px; }
      #right-joystick { bottom: 25px; right: 25px; }
    }

    /* ØªØ­Ø³ÙŠÙ†Ø§Øª Ù„Ù„Ø´Ø§Ø´Ø§Øª Ø§Ù„ÙƒØ¨ÙŠØ±Ø© */
    @media (min-width: 769px) and (max-width: 1024px) {
      .joystick-container{
        display:flex;
        width: 100px;
        height: 100px;
      }
      
      .joystick-stick {
        width: 50px;
        height: 50px;
      }
    }

    /* Ù…Ø¤Ø´Ø±Ø§Øª HUD Ù…Ø­Ø³Ù†Ø© */
    .hud-indicator {
      position: absolute;
      font-size: 20px;
      z-index: 50;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
    }

    /* ================================== */
    /* === Ø§Ù„ØªØ¹Ø¯ÙŠÙ„Ø§Øª Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„Ù…Ø¸Ù‡Ø± === */
    /* ================================== */

    /* 1. Ø¥Ø¶Ø§ÙØ© Ø¸Ù„ Ù„Ù„Ù†Øµ Ù„Ø¬Ø¹Ù„Ù‡ ÙŠØ¨Ø±Ø² Ø¨Ø´ÙƒÙ„ Ø£ÙØ¶Ù„ */
    h1, h2, h3, p, .hud-indicator, #score-board, #menu p, #upgrade-menu p {
        text-shadow: 0px 0px 4px rgba(0, 0, 0, 0.8), 0px 0px 10px var(--accent);
    }

    /* 2. ØªØ­Ø³ÙŠÙ† Ø´ÙƒÙ„ Ø²Ø± Ø§Ù„Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù…Ø¤Ù‚Øª (Pause Button) */
    #pause-btn {
        border: none;
        box-shadow: 0 0 10px rgba(255, 209, 102, 0.5); /* Ø¸Ù„ Ø­ÙˆÙ„ Ø§Ù„Ø²Ø± */
        transition: all 0.2s; /* Ù„Ø¬Ø¹Ù„ Ø§Ù„Ø­Ø±ÙƒØ© Ù†Ø§Ø¹Ù…Ø© */
    }

    #pause-btn:hover {
        box-shadow: 0 0 15px var(--accent); /* Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø¸Ù„ Ø¹Ù†Ø¯ Ø§Ù„ØªÙ…Ø±ÙŠØ± */
        transform: scale(1.05); /* ØªÙƒØ¨ÙŠØ± Ø®ÙÙŠÙ */
    }
    /* ======= ØªØ­Ø³ÙŠÙ† Ø§Ù„Ø´Ø±ÙŠØ· Ø§Ù„Ø¹Ù„ÙˆÙŠ ======= */
.top-bar {
  display: flex;
  align-items: center;
  justify-content: space-around;
  flex-wrap: nowrap;
  gap: 6px;
  overflow-x: auto;
  white-space: nowrap;
}

.top-bar::-webkit-scrollbar {
  display: none;
}

.top-bar .btn, .top-bar .pill {
  flex-shrink: 0;
}

.pill {
  background: rgba(255, 255, 255, 0.08);
  border-radius: 999px;
  padding: 6px 12px;
  font-size: 14px;
  box-shadow: 0 0 6px rgba(255,255,255,0.1);
}

#health-display {
  background: rgba(255, 0, 0, 0.15);
  border: 1px solid rgba(255, 100, 100, 0.3);
}
  </style>
</head>
<body>
  <div id="game-wrap">
<header>
  <div class="controls top-bar">
    <button id="settingsBtn" class="btn small">â¸ï¸</button>
    <button id="restart" class="btn small">ğŸ”„</button>
    <div class="pill">ğŸ’° <strong id="permanent-score">0</strong></div>
    <div class="pill" id="health-display">â¤ï¸ <strong id="health-count">3</strong></div>
  </div>
</header>

    <canvas id="game"></canvas>

    <div id="health-bar" style="position:absolute; top:10px; left:50%; transform:translateX(-50%); display:none;">
      <div style="background:rgba(255,0,0,0.3); width:200px; height:8px; border-radius:4px;">
        <div id="health-fill" style="background:#00ff00; height:100%; width:100%; border-radius:4px; transition:width 0.3s;"></div>
      </div>
    </div>

  </div>
  
  <div id="overlay" aria-hidden="true" style="display:none">
    <div class="menu" role="dialog" aria-label="Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©">
      
      <div id="main-menu" style="display:none">
        <h3>â™¾ï¸Ù„Ø¹Ø¨Ø© Ø§Ù„Ø¨Ù‚Ø§Ø¡â™¾ï¸</h3>
        <div <button id="start-game-btn" class="btn"><h2>Ø§Ø¨Ø¯Ø£ Ø§Ù„Ù„Ø¹Ø¨Ø©</h2></button></div>
        <button id="store-menu-btn" class="btn small" style="margin-top:10px"><h2>ğŸ›’</h2></button>
        <button id="scores-menu-btn" class="btn small" style="margin-top:10px"><h2>Ø£ÙØ¶Ù„ 10 Ù†ØªØ§Ø¦Ø¬</h2></button>
        <button id="settings-menu-btn" class="btn small"><h2>âš™ï¸</h2></button>
      </div>

      <div id="settings-menu" style="display:none">
        <h3>Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©</h3>
        <div class="row"><label>Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµØ¹ÙˆØ¨Ø©:</label>
          <select id="difficulty"><option value="easy">Ø³Ù‡Ù„</option><option value="normal" selected>Ø¹Ø§Ø¯ÙŠ</option><option value="hard">ØµØ¹Ø¨</option></select>
        </div>
            <div class="pill">ğŸ” <strong id="score">0</strong></div>
        <div class="row"><label>Ø§Ù„ØµÙˆØª:</label><input type="checkbox" id="soundToggle" checked><span class="muted">(ØªØ£Ø«ÙŠØ±Ø§Øª)</span></div>
        <div class="row"><label>Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ø®Ù„ÙÙŠØ©:</label><input type="checkbox" id="musicToggle" checked><span class="muted">(Ù…ÙˆÙ„Ø¯ ØµÙˆØªÙŠ)</span></div>
        <div class="row"><label>Ø­Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ù‡Ø¯Ù:</label><input id="sensitivity" type="range" min="0.5" max="2" step="0.1" value="1"></div>&nbsp;&nbsp;
        Ø£ÙØ¶Ù„ Ù†ØªÙŠØ¬Ø©: <strong id="highscore">0</strong>
        &nbsp;&nbsp;
        <div       <button id="header-store-btn" class="btn small" style="margin-top:0px"><h3>ğŸ›’</h3></button></div> <div style="margin-top:10px;text-align:right"><button id="close-settings-btn" class="btn small">Ø­ÙØ¸ ÙˆØ¥ØºÙ„Ø§Ù‚</button></div>
      </div>

      <div id="scores-menu" style="display:none">
        <h3>Ø£ÙØ¶Ù„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬</h3>
        <ul id="score-list" style="list-style:none;padding:0;text-align:right;font-size:14px"></ul>
        <div style="margin-top:10px;text-align:right"><button id="close-scores-btn" class="btn small">Ø¥ØºÙ„Ø§Ù‚</button></div>
      </div>
      
      <div id="store-menu" style="display:none">
        <h3>Ù…ØªØ¬Ø± Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª Ø§Ù„Ø¯Ø§Ø¦Ù…Ø© ğŸ’</h3>
        <div style="margin-top:10px;text-align:right"><button id="close-store-btn" class="btn small">Ø¥ØºÙ„Ø§Ù‚</button></div>
        <p>Ù†Ù‚Ø§Ø·Ùƒ Ø§Ù„Ø¯Ø§Ø¦Ù…Ø© Ø§Ù„Ø­Ø§Ù„ÙŠØ©: <strong id="current-permanent-score-store">0</strong></p> 
        <div id="store-items-list">
            </div>
      </div>
      
      <div id="upgrade-menu" style="display:none">
        <h3>Ø§ÙƒØªÙ…Ù„ Ø§Ù„Ù…Ø³ØªÙˆÙ‰!</h3>
        <p>Ø§Ø®ØªØ± ØªØ±Ù‚ÙŠØ© Ù…Ø¤Ù‚ØªØ© Ù„Ù‡Ø°Ø§ Ø§Ù„Ø¬ÙˆÙ„Ø©:</p>
        <button id="upgrade-fire-rate" class="upgrade-option">Ù…Ø¹Ø¯Ù„ Ø¥Ø·Ù„Ø§Ù‚ Ø£Ø³Ø±Ø¹</button>
        <button id="upgrade-speed" class="upgrade-option">Ø³Ø±Ø¹Ø© Ø­Ø±ÙƒØ© Ø£ÙƒØ¨Ø±</button>
        <button id="upgrade-bullet-power" class="upgrade-option">Ù‚ÙˆØ© Ø±ØµØ§Øµ Ø¥Ø¶Ø§ÙÙŠØ©</button>
        </div>
    </div>
  </div>

  <div id="left-joystick" class="joystick-container">
    <div class="joystick-stick"></div>
  </div>
  <div id="right-joystick" class="joystick-container">
    <div class="joystick-stick"></div>
  </div>

  <div id="hud-indicators" style="position:fixed; top:10px; right:10px; z-index:50; display:none;">
    <div id="rapid-indicator" class="hud-indicator" style="display:none;">ğŸš€</div>
    &nbsp;<div id="shield-indicator" class="hud-indicator" style="display:none;">ğŸ›¡ï¸</div>
    &nbsp;<div id="magnet-indicator" class="hud-indicator" style="display:none;">ğŸ§²</div>
    &nbsp;<div id="slowdown-indicator" class="hud-indicator" style="display:none;">ğŸŒ</div>
    <div id="speed-indicator" class="hud-indicator" style="display:none; transform:translateY(25px);"></div> 
  </div>


  <script>

// === Ù„Ø¹Ø¨Ø© Ù…Ø­Ø³Ù†Ø© Ù…Ø¹ Ù…ØªØ¬Ø± Ø¯Ø§Ø¦Ù… ÙˆÙ…Ø³ØªÙˆÙŠØ§Øª Ù…Ø³ØªÙ…Ø±Ø© ===
(() => {
    // === Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ÙˆÙ…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ===
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    
    // ØªØ­Ø³ÙŠÙ† Ù†Ø¸Ø§Ù… Ø¶Ø¨Ø· Ø§Ù„Ø­Ø¬Ù…
    const PADDING = 120;//Ø­Ø¬Ù… Ø§Ù„Ø¹Ø§Ù„Ù…
    let W//Ù„Ù„Ø¹Ø±Ø¶, H//Ù„Ù„Ø·ÙˆÙ„;
    let animationFrameId = null;
    
    function fitCanvas() {
        const wrap = document.getElementById('game-wrap');
        const header = document.querySelector('header');
        
        const maxW = Math.min(window.innerWidth - 40, 1200);
        const maxH = Math.min(window.innerHeight - (header?.offsetHeight || 60) - 40, 800);
        
        canvas.width = maxW;
        canvas.height = maxH;
        
        W = canvas.width;
        H = canvas.height;
        
        // ØªØ­Ø¯ÙŠØ« Ø­Ø¬Ù… Ø¯ÙˆØ§Ø¦Ø± Ø§Ù„ØªØ­ÙƒÙ…
        updateJoystickSize();
    }

    function updateJoystickSize() {
        const isMobile = window.innerWidth <= 768;
        if (isMobile) {
            const baseSize = Math.min(window.innerWidth, window.innerHeight) * 0.18//Ø­Ø¬Ù… Ø¯ÙˆØ§Ø¦Ø± Ø§Ù„ØªØ­ÙƒÙ…;
            const stickSize = baseSize * 0.4//Ø­Ø¬Ù… Ø§Ø²Ø±Ø§Ø± Ø¯ÙˆØ§Ø¦Ø± Ø§Ù„ØªØ­ÙƒÙ…;
            
            document.querySelectorAll('.joystick-container').forEach(joy => {
                joy.style.width = Math.min(baseSize, 120) + 'px';
                joy.style.height = Math.min(baseSize, 120) + 'px';
            });
            
            document.querySelectorAll('.joystick-stick').forEach(stick => {
                stick.style.width = Math.min(stickSize, 50) + 'px';
                stick.style.height = Math.min(stickSize, 50) + 'px';
            });
        }
    }

    window.addEventListener('resize', fitCanvas);
    fitCanvas();

    // Ø­Ø§Ù„Ø© Ø§Ù„Ù„Ø¹Ø¨Ø©
    let keys = {}, mouse = { x: 0, y: 0, down: false }, score = 0, permanentScore = 0, running = false, gameOver = false, inMenu = true;
    const camera = { x: 0, y: 0 };

    // ØªØ­Ø³ÙŠÙ† Ø¯ÙˆØ§Ø¦Ø± Ø§Ù„ØªØ­ÙƒÙ…
    let leftJoystick = { active: false, startX: 0, startY: 0, dx: 0, dy: 0, touchId: null, maxDist: 40 };
    let rightJoystick = { active: false, startX: 0, startY: 0, dx: 0, dy: 0, touchId: null, maxDist: 40 };
    
    // Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªØ¹Ø¯ÙŠÙ„
    const state = { difficulty: 'normal', sound: true, music: true, sensitivity: 1 };
    
    // Ø¹Ù†Ø§ØµØ± DOM
    const scoreEl = document.getElementById('score');
    const permanentScoreEl = document.getElementById('permanent-score'); // Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø¯Ø§Ø¦Ù…Ø© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
    const hsEl = document.getElementById('highscore');
    const restartBtn = document.getElementById('restart');
    const settingsBtn = document.getElementById('settingsBtn');
    const overlay = document.getElementById('overlay');
    const healthBar = document.getElementById('health-bar');
    const healthFill = document.getElementById('health-fill');
    const hudIndicators = document.getElementById('hud-indicators');
    
    // Ø§Ù„Ù‚ÙˆØ§Ø¦Ù…
    const mainMenu = document.getElementById('main-menu');
    const settingsMenu = document.getElementById('settings-menu');
    const scoresMenu = document.getElementById('scores-menu');
    const upgradeMenu = document.getElementById('upgrade-menu');
    const storeMenu = document.getElementById('store-menu'); 
    
    // Ø§Ù„Ø£Ø²Ø±Ø§Ø±
    const startGameBtn = document.getElementById('start-game-btn');
    const settingsMenuBtn = document.getElementById('settings-menu-btn');
    const scoresMenuBtn = document.getElementById('scores-menu-btn');
    const closeSettingsBtn = document.getElementById('close-settings-btn');
    const closeScoresBtn = document.getElementById('close-scores-btn');
    const storeMenuBtn = document.getElementById('store-menu-btn');
    const closeStoreBtn = document.getElementById('close-store-btn');
    const headerStoreBtn = document.getElementById('header-store-btn'); 

    const upgradeFireRateBtn = document.getElementById('upgrade-fire-rate');
    const upgradeSpeedBtn = document.getElementById('upgrade-speed');
    const upgradeBulletPowerBtn = document.getElementById('upgrade-bullet-power');
    // ØªÙ… Ø­Ø°Ù Ø²Ø± Ø§Ù„Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬ Ø§Ù„Ù…Ø¤Ù‚Øª
    
    // Ø¹Ù†Ø§ØµØ± Ø¯ÙˆØ§Ø¦Ø± Ø§Ù„ØªØ­ÙƒÙ…
    const leftJoystickEl = document.getElementById('left-joystick');
    const rightJoystickEl = document.getElementById('right-joystick');
    const leftJoystickStickEl = leftJoystickEl.querySelector('.joystick-stick');
    const rightJoystickStickEl = rightJoystickEl.querySelector('.joystick-stick');

    // === Ù†Ø¸Ø§Ù… Ø§Ù„ØµÙˆØª Ø§Ù„Ù…Ø­Ø³Ù‘Ù† ===
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    let audioCtx = null;
    
    function ensureAudio() {
        if (!audioCtx) {
            audioCtx = new AudioCtx();
            // Ø¥Ø¶Ø§ÙØ© Ù…Ø¹Ø§Ù„Ø¬ Ù„Ù„ØªØ¹Ø§Ù…Ù„ Ù…Ø¹ Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„ØµÙˆØª ØªÙ„Ù‚Ø§Ø¦ÙŠØ§Ù‹
            document.addEventListener('click', () => {
                if (audioCtx && audioCtx.state === 'suspended') {
                    audioCtx.resume().catch(() => {});
                }
            }, { once: true });
        }
        return audioCtx;
    }

    // Ù†Ø¸Ø§Ù… ØµÙˆØªÙŠ Ø£ÙƒØ«Ø± Ø§Ø³ØªÙ‚Ø±Ø§Ø±Ø§Ù‹
    function safePlayBeep(freq, duration, type = 'sine', gain = 0.12) {
        if (!state.sound) return;
        
        try {
            const ctx = ensureAudio();
            if (ctx.state === 'suspended') {
                ctx.resume().then(() => {
                    playBeep(freq, duration, type, gain);
                }).catch(() => {});
                return;
            }
            
            const o = ctx.createOscillator();
            const g = ctx.createGain();
            o.type = type;
            o.frequency.value = freq;
            g.gain.value = gain;
            g.gain.exponentialRampToValueAtTime(0.001, ctx.currentTime + duration);
            o.connect(g);
            g.connect(ctx.destination);
            o.start();
            o.stop(ctx.currentTime + duration);
            
            // ØªÙ†Ø¸ÙŠÙ Ø§Ù„Ø°Ø§ÙƒØ±Ø©
            setTimeout(() => {
                try {
                    o.disconnect();
                    g.disconnect();
                } catch (e) {}
            }, duration * 1000 + 100);
            
        } catch (error) {
            console.log('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„ØµÙˆØª:', error);
        }
    }

    // Ù…ÙˆØ³ÙŠÙ‚Ù‰ Ø®Ù„ÙÙŠØ© Ù…Ø­Ø³Ù†Ø©
    let bgGain = null, bgOsc = null, bgInterval = null;
    
    function startMusic() {
        if (!state.music) return;
        stopMusic();
        
        try {
            const ctx = ensureAudio();
            if (ctx.state === 'suspended') return;
            
            bgOsc = ctx.createOscillator();
            bgGain = ctx.createGain();
            
            bgOsc.type = 'sine';
            bgOsc.frequency.value = 110;
            bgGain.gain.value = 0.02;
            
            bgOsc.connect(bgGain);
            bgGain.connect(ctx.destination);
            bgOsc.start();
            
            // ØªØºÙŠÙŠØ± Ø§Ù„Ù†ØºÙ…Ø© Ø¨Ø´ÙƒÙ„ Ø¯ÙˆØ±ÙŠ Ù„Ù…Ù†Ø¹ Ø§Ù„Ù…Ù„Ù„
            bgInterval = setInterval(() => {
                if (bgOsc) {
                    bgOsc.frequency.linearRampToValueAtTime(110 + Math.random() * 40 - 20, ctx.currentTime + 2);
                }
            }, 3000);
            
        } catch (error) {
            console.log('Ø®Ø·Ø£ ÙÙŠ Ø§Ù„Ù…ÙˆØ³ÙŠÙ‚Ù‰:', error);
        }
    }

    function stopMusic() {
        if (bgInterval) {
            clearInterval(bgInterval);
            bgInterval = null;
        }
        if (bgOsc) {
            try { bgOsc.stop(); } catch (e) {}
            try { bgOsc.disconnect(); } catch (e) {}
            bgOsc = null;
        }
        if (bgGain) {
            try { bgGain.disconnect(); } catch (e) {}
            bgGain = null;
        }
    }
    
    // === Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø¯Ø§Ø¦Ù…Ø© (Ø§Ù„Ø¹Ù…Ù„Ø©) ===
    function loadPermanentScore() {
        try {
            const savedScore = localStorage.getItem('hami_permanent_score');
            return savedScore ? parseInt(savedScore) : 0;
        } catch (e) {
            console.error("Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø¯Ø§Ø¦Ù…Ø©:", e);
            return 0;
        }
    }

    function savePermanentScore() {
        try {
            localStorage.setItem('hami_permanent_score', permanentScore);
            permanentScoreEl.textContent = permanentScore;
        } catch (e) {
            console.error("Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø¯Ø§Ø¦Ù…Ø©:", e);
        }
    }

    // ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø¯Ø§Ø¦Ù…Ø© Ø¹Ù†Ø¯ Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø©
    permanentScore = loadPermanentScore();
    permanentScoreEl.textContent = permanentScore;

    // Ø¯Ø§Ù„Ø© Ù„Ø¥Ø¶Ø§ÙØ© Ù†Ù‚Ø§Ø· Ø§Ù„Ø¬ÙˆÙ„Ø© Ø¥Ù„Ù‰ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø¯Ø§Ø¦Ù…Ø© Ø¹Ù†Ø¯ Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ø¬ÙˆÙ„Ø©
    function addScoreToPermanent(v) {
        permanentScore += v;
        savePermanentScore();
    }


    // === Ù†Ø¸Ø§Ù… Ø§Ù„Ù…ØªØ¬Ø± Ø§Ù„Ø¯Ø§Ø¦Ù… (Ø¬Ø¯ÙŠØ¯) ===
    class PermanentStore {
        constructor() {
            this.MAX_LEVELS = {
                fireRate: 5, 
                speed: 5,     
                power: 5,     
                maxHp: 3,     
                doubleShot: 3  // ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬
            };
            this.BASE_PRICES = {
                fireRate: 100000, // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø³Ø¹Ø±
                speed: 80000,     // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø³Ø¹Ø±
                power: 120000,    // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø³Ø¹Ø±
                maxHp: 200000,    // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø³Ø¹Ø±
                doubleShot: 1500000 // Ø²ÙŠØ§Ø¯Ø© Ø§Ù„Ø³Ø¹Ø±
            };
            this.upgrades = this.loadUpgrades();
        }

        loadUpgrades() {
            try {
                const data = localStorage.getItem('hami_permanent_upgrades');
                const loaded = data ? JSON.parse(data) : {};
                
                // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† ØªÙ‡ÙŠØ¦Ø© ÙƒÙ„ ØªØ±Ù‚ÙŠØ© Ø¨Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ø¯Ù†Ù‰
                const defaults = { fireRate: 0, speed: 0, power: 0, maxHp: 0, doubleShot: 0 };
                return { ...defaults, ...loaded };
            } catch (e) {
                console.error("Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ ØªØ±Ù‚ÙŠØ§Øª Ø§Ù„Ù…ØªØ¬Ø±:", e);
                return { fireRate: 0, speed: 0, power: 0, maxHp: 0, doubleShot: 0 };
            }
        }

        saveUpgrades() {
            try {
                localStorage.setItem('hami_permanent_upgrades', JSON.stringify(this.upgrades));
            } catch (e) {
                console.error("Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ ØªØ±Ù‚ÙŠØ§Øª Ø§Ù„Ù…ØªØ¬Ø±:", e);
            }
        }
        
        getCost(upgradeKey, level = this.upgrades[upgradeKey]) {
            const basePrice = this.BASE_PRICES[upgradeKey];
            
            // Ø²ÙŠØ§Ø¯Ø© ÙÙŠ Ø§Ù„Ø³Ø¹Ø± (ØªØµØ¨Ø­ Ø§Ù„ØªØ±Ù‚ÙŠØ© Ø£ØµØ¹Ø¨)
            return Math.round(basePrice * Math.pow(2.5, level)); // Ø²ÙŠØ§Ø¯Ø© Ù†Ø³Ø¨Ø© Ø§Ù„ØµØ¹ÙˆØ¨Ø© Ù…Ù† 1.5 Ø¥Ù„Ù‰ 1.8
        }
        
        getSellPrice(upgradeKey) {
            const currentLevel = this.upgrades[upgradeKey];
            if (currentLevel === 0) return 0;
            
            // Ø³Ø¹Ø± Ø§Ù„Ø´Ø±Ø§Ø¡ Ù„Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø°ÙŠ ØªÙ… Ø¨ÙŠØ¹Ù‡ (Ø£ÙŠ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø­Ø§Ù„ÙŠ - 1)
            const purchaseCostOfThisLevel = this.getCost(upgradeKey, currentLevel - 1); 
            
            // Ù‚ÙŠÙ…Ø© Ø§Ù„Ø¨ÙŠØ¹ Ù‡ÙŠ Ù†ØµÙ Ø«Ù…Ù† Ø§Ù„Ø´Ø±Ø§Ø¡ (ÙƒÙ…Ø§ Ø·Ù„Ø¨Øª)
            return Math.floor(purchaseCostOfThisLevel / 2);
        }


        canBuy(upgradeKey, currentScore) {
            const cost = this.getCost(upgradeKey);
            const maxLevel = this.MAX_LEVELS[upgradeKey];
            
            return currentScore >= cost && this.upgrades[upgradeKey] < maxLevel;
        }

        buyUpgrade(upgradeKey) {
            const cost = this.getCost(upgradeKey);
            if (this.canBuy(upgradeKey, permanentScore)) {
                permanentScore -= cost; // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø¯Ø§Ø¦Ù…Ø©
                this.upgrades[upgradeKey] = Math.min(this.upgrades[upgradeKey] + 1, this.MAX_LEVELS[upgradeKey]);
                this.saveUpgrades();
                savePermanentScore(); // Ø­ÙØ¸ Ø§Ù„Ø¹Ù…Ù„Ø©
                return true;
            }
            return false;
        }
        
        // **ÙˆØ¸ÙŠÙØ© Ø¨ÙŠØ¹ Ø§Ù„ØªØ±Ù‚ÙŠØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©**
        sellUpgrade(upgradeKey) {
            const currentLevel = this.upgrades[upgradeKey];
            if (currentLevel > 0) {
                const refund = this.getSellPrice(upgradeKey);
                permanentScore += refund;
                this.upgrades[upgradeKey] = currentLevel - 1;
                this.saveUpgrades();
                savePermanentScore();
                return true;
            }
            return false;
        }

        applyToPlayer(player) {
            const u = this.upgrades;
            
            // 1. Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø£ÙˆÙ„ÙŠØ© (Ø§Ù„Ø«Ø§Ø¨ØªØ©) Ù‚Ø¨Ù„ ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª Ø§Ù„Ø¯Ø§Ø¦Ù…Ø©
            player.initialSpeed = 220;
            player.initialReload = 0.12;
            player.initialBulletPower = 1;
            player.maxHp = 3;
            
            // 2. ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø²ÙŠØ§Ø¯Ø§Øª Ø§Ù„Ø¯Ø§Ø¦Ù…Ø© Ø¹Ù„Ù‰ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø£ÙˆÙ„ÙŠØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©:
            // Ù…Ø¹Ø¯Ù„ Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù†Ø§Ø±: * 0.8 Ù„ÙƒÙ„ Ù…Ø³ØªÙˆÙ‰
            player.initialReload *= Math.pow(0.8, u.fireRate); 
            
            // Ø³Ø±Ø¹Ø© Ø§Ù„Ø­Ø±ÙƒØ©: * 1.1 Ù„ÙƒÙ„ Ù…Ø³ØªÙˆÙ‰
            player.initialSpeed *= Math.pow(1.1, u.speed); 
            
            // Ù‚ÙˆØ© Ø§Ù„Ø±ØµØ§Øµ: +2 Ù‚ÙˆØ© Ø±ØµØ§Øµ Ù„ÙƒÙ„ Ù…Ø³ØªÙˆÙ‰
            player.initialBulletPower += (u.power * 2); 
            
            // Ø§Ù„Ø­Ø¯ Ø§Ù„Ø£Ù‚ØµÙ‰ Ù„Ù„Ø­ÙŠØ§Ø©: +1 Ø­ÙŠØ§Ø© Ù„ÙƒÙ„ Ù…Ø³ØªÙˆÙ‰
            player.maxHp += u.maxHp; 
            
            // 3. ØªØ·Ø¨ÙŠÙ‚ Ù‚ÙŠÙ…Ø© Ø§Ù„Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬
            // ØªØ²ÙŠØ¯ Ø¹Ø¯Ø¯ Ø§Ù„Ø±ØµØ§ØµØ§Øª Ø§Ù„ØªÙŠ ÙŠØªÙ… Ø¥Ø·Ù„Ø§Ù‚Ù‡Ø§ (1 + Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ±Ù‚ÙŠØ©)
            player.doubleShotPermanentLevel = u.doubleShot; 
            // Ø§Ù„Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬ ÙŠØ¨Ø¯Ø£ Ù…Ù† Ø§Ù„Ù…Ø³ØªÙˆÙ‰ 1 (Ø¨Ù…Ø¹Ù†Ù‰ Ø¥Ø·Ù„Ø§Ù‚ Ø±ØµØ§ØµØªÙŠÙ†)
            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªÙˆÙ‰ 1: ÙŠØ·Ù„Ù‚ Ø±ØµØ§ØµØªÙŠÙ† (1 Ø¥Ø¶Ø§ÙÙŠØ©)
            // Ø¥Ø°Ø§ ÙƒØ§Ù† Ø§Ù„Ù…Ø³ØªÙˆÙ‰ 2: ÙŠØ·Ù„Ù‚ 3 Ø±ØµØ§ØµØ§Øª (2 Ø¥Ø¶Ø§ÙÙŠØ©)
        }
    }
    
    const permanentStore = new PermanentStore();


    // === ÙƒØ§Ø¦Ù†Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø© Ù…Ø¹ ØªØ­Ø³ÙŠÙ†Ø§Øª Ø§Ù„Ø£Ø¯Ø§Ø¡ ===
    const player = {
        x: 0, y: 0, r: 16,
        speed: 220,
        color: '#ffd166',
        reload: 0.12,
        reloadTimer: 0,
        bulletPower: 1,
        doubleShot: false, // ØªØ±Ù‚ÙŠØ© Ù…Ø¤Ù‚ØªØ© (Ø§Ù„Ø¢Ù† ÙÙ‚Ø· Ù„Ø¨Ø¹Ø¶ Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ© Ø§Ù„ØªÙŠ Ù‚Ø¯ Ù†Ø¶ÙŠÙÙ‡Ø§ Ù„Ø§Ø­Ù‚Ù‹Ø§)
        doubleShotPermanentLevel: 0, // Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ±Ù‚ÙŠØ© Ø§Ù„Ø¯Ø§Ø¦Ù…Ø© Ù„Ù„Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬
        initialSpeed: 220,
        initialReload: 0.12,
        initialBulletPower: 1,
        hp: 3,
        maxHp: 3,
        shieldTimer: 0,
        magnetTimer: 0,
        upgrades: { fireRate: 0, speed: 0, bulletPower: 0 } // ØªØ±Ù‚ÙŠØ§Øª Ù…Ø¤Ù‚ØªØ© Ù„Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ø­Ø§Ù„ÙŠ
    };

    // Ø£Ù†Ø¸Ù…Ø© ØªØ®Ø²ÙŠÙ† Ù…Ø­Ø³Ù†Ø© Ù…Ø¹ object pooling
    let bullets = [], enemies = [], particles = [], powerups = [];
    const particlePool = [];
    const bulletPool = [];
    
    // ÙˆØ¸Ø§Ø¦Ù Ù…Ø³Ø§Ø¹Ø¯Ø© Ù„Ù„Ø°Ø§ÙƒØ±Ø©
    function createParticle(x, y, color) {
        if (particlePool.length > 0) {
            const p = particlePool.pop();
            Object.assign(p, {
                x, y, life: rand(0.4, 1.4),
                vx: rand(-180, 180), vy: rand(-180, 180),
                r: rand(1, 4), c: color
            });
            return p;
        }
        return {
            x, y, life: rand(0.4, 1.4),
            vx: rand(-180, 180), vy: rand(-180, 180),
            r: rand(1, 4), c: color
        };
    }
    
    function recycleParticle(particle) {
        if (particlePool.length < 1000) {
            particlePool.push(particle);
        }
    }

    // Ù…ØªØºÙŠØ±Ø§Øª Ø§Ù„Ù„Ø¹Ø¨Ø©
    let spawnTimer = 0, spawnRate = 1.2, elapsed = 0, level = 1, enemiesToSpawn = 0;
    let boss = null, enemiesDefeatedInLevel = 0;
    let enemiesPerLevel = 25;
    let rapidFireTimer = 0, slowdownTimer = 0;
    // ØªÙ… Ø¥Ù„ØºØ§Ø¡ ÙˆØ¶Ø¹ Ø§Ù„Ù†Ø¬Ø§Ø© Survival Mode Ù„Ø¬Ø¹Ù„Ù‡ Ù„Ø¹Ø¨ Ù…Ø³ØªÙ…Ø±
    let survivalMode = false, survivalTimer = 0; 

    // === Ù†Ø¸Ø§Ù… Ø§Ù„Ù†ØªØ§Ø¦Ø¬ Ø§Ù„Ù…Ø­Ø³Ù‘Ù† (Ù†Ù‚Ø§Ø· Ø§Ù„Ø¬ÙˆÙ„Ø©) ===
    function loadHighScores() {
        try {
            const data = localStorage.getItem('hami_scores');
            if (!data) return [];
            
            const parsed = JSON.parse(data);
            return Array.isArray(parsed) ? parsed.slice(0, 10) : [];
        } catch (e) {
            console.log('Ø®Ø·Ø£ ÙÙŠ ØªØ­Ù…ÙŠÙ„ Ø§Ù„Ù†ØªØ§Ø¦Ø¬:', e);
            return [];
        }
    }

    function saveHighScores(arr) {
        try {
            const toSave = arr.slice(0, 10); // Ø§Ù„ØªØ£ÙƒØ¯ Ù…Ù† Ø¹Ø¯Ù… ØªØ¬Ø§ÙˆØ² 10 Ù†ØªØ§Ø¦Ø¬
            localStorage.setItem('hami_scores', JSON.stringify(toSave));
            localStorage.setItem('hami_scores_backup', JSON.stringify(toSave));
        } catch (e) {
            console.log('Ø®Ø·Ø£ ÙÙŠ Ø­ÙØ¸ Ø§Ù„Ù†ØªØ§Ø¦Ø¬:', e);
        }
    }

    // ØªÙ… ØªØ¹Ø¯ÙŠÙ„ Ø¯Ø§Ù„Ø© pushScore Ù„Ø¥Ø¶Ø§ÙØ© Ø§Ù„Ù†Ù‚Ø§Ø· Ø¥Ù„Ù‰ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø¯Ø§Ø¦Ù…Ø©
    function pushScore(v) {
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø¹Ø§Ù„ÙŠØ©
        const arr = loadHighScores();
        arr.push({ 
            score: v, 
            date: new Date().toISOString(),
            level: level,
            difficulty: state.difficulty
        });
        
        arr.sort((a, b) => b.score - a.score);
        saveHighScores(arr);
        updateHSDisplay();
        
        // **Ø§Ù„Ø®Ø·ÙˆØ© Ø§Ù„Ø£Ù‡Ù…: ØªØ­ÙˆÙŠÙ„ Ù†Ù‚Ø§Ø· Ø§Ù„Ø¬ÙˆÙ„Ø© Ø¥Ù„Ù‰ Ù†Ù‚Ø§Ø· Ø¯Ø§Ø¦Ù…Ø©**
        addScoreToPermanent(v);
    }

    function updateHSDisplay() {
        const arr = loadHighScores();
        hsEl.textContent = arr.length ? arr[0].score : '0';
        permanentScoreEl.textContent = permanentScore; // ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø¯Ø§Ø¦Ù…Ø©
    }
    updateHSDisplay();

    // === ÙˆØ¸Ø§Ø¦Ù Ù…Ø³Ø§Ø¹Ø¯Ø© Ù…Ø­Ø³Ù†Ø© ===
    function rand(min, max) { 
        return Math.random() * (max - min) + min; 
    }
    
    function dist(a, b) { 
        const dx = a.x - b.x, dy = a.y - b.y; 
        return Math.sqrt(dx * dx + dy * dy); 
    }
    
    function clamp(value, min, max) {
        return Math.max(min, Math.min(max, value));
    }

// ===================================
// === ÙØ¦Ø© Ø§Ù„Ø¹Ø¯Ùˆ (Enemy Class) ===
// ===================================
class Enemy {
    constructor(x, y, type, level) {
        this.x = x;
        this.y = y;
        this.type = type;
        this.r = 14; // Ø§Ù„Ø­Ø¬Ù… Ø§Ù„Ø£Ø³Ø§Ø³ÙŠ
        this.score = 100; // Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
        
        const difficulty = calculateDifficulty();
        // Ø²ÙŠØ§Ø¯Ø© Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØµØ¹ÙˆØ¨Ø© Ø¨Ø¨Ø·Ø¡ Ø£ÙƒØ«Ø± ÙÙŠ Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ù…ØªÙ‚Ø¯Ù…Ø©
        const levelFactor = 1 + (level - 1) * 0.10; 

        // Ø®ØµØ§Ø¦Øµ Ø¥Ø¶Ø§ÙÙŠØ© Ù„Ù„Ø¹Ø¯Ùˆ Ø§Ù„ÙÙˆØ¶ÙˆÙŠ
        if (type === 'chaotic') {
            this.angle = rand(0, Math.PI * 2); // Ø²Ø§ÙˆÙŠØ© Ø­Ø±ÙƒØ© Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
            this.moveTimer = 0; // Ù…Ø¤Ù‚Øª Ù„ØªØºÙŠÙŠØ± Ø§Ù„Ø§ØªØ¬Ø§Ù‡
        }

        // ØªØ­Ø¯ÙŠØ¯ Ø§Ù„Ø®ØµØ§Ø¦Øµ Ø­Ø³Ø¨ Ù†ÙˆØ¹ Ø§Ù„Ø¹Ø¯Ùˆ
        switch (type) {
            case 'normal':
                this.speed = 110 * difficulty.enemySpeed * levelFactor;
                this.color = '#ef476f'; 
                this.hp = Math.round(1 * difficulty.enemyHealth * levelFactor);
                this.score =100* levelFactor;
                break;
            case 'fast':
                this.speed = 220 * difficulty.enemySpeed * levelFactor;
                this.color = '#00e0ff'; 
                this.hp = Math.round(1 * difficulty.enemyHealth * levelFactor);
                this.score = 200* levelFactor;
                break;
            case 'tank':
                this.speed = 80 * difficulty.enemySpeed * levelFactor;
                this.color = '#7851a9';
                this.r = 17; // Ø­Ø¬Ù… Ø£ÙƒØ¨Ø± Ù‚Ù„ÙŠÙ„Ø§Ù‹ Ù„Ù„Ø¯Ø¨Ø§Ø¨Ø©
                this.hp = Math.round(4 * difficulty.enemyHealth * levelFactor);
                this.score = 300* levelFactor;
                break;
            case 'shooter':
                this.speed = 90  * difficulty.enemySpeed * levelFactor;
                this.color = '#ff6f91';
                this.hp = Math.round(2 * difficulty.enemyHealth * levelFactor);
                this.shootTimer = rand(1, 2); 
                this.shootReload = 2;
                this.score = 250* levelFactor;
                break;
            case 'kamikaze':
                this.speed = 180 * difficulty.enemySpeed * levelFactor;
                this.color = '#ff0000';
                this.r = 14;
                this.hp = Math.round(1 * difficulty.enemyHealth * levelFactor);
                this.score = 200* levelFactor;
                break;
            case 'chaotic': // Ø§Ù„Ø¹Ø¯Ùˆ Ø§Ù„ÙÙˆØ¶ÙˆÙŠ Ø§Ù„Ø¬Ø¯ÙŠØ¯
                this.speed = rand(1.5, 2.5) * 100 * difficulty.enemySpeed * levelFactor; // Ø£Ø³Ø±Ø¹ Ù…Ù† Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡ Ø§Ù„Ø¹Ø§Ø¯ÙŠÙŠÙ†
                this.color = '#ff00ff'; 
                this.r = 14;
                this.hp = Math.round(2 * difficulty.enemyHealth * levelFactor);
                this.score = 400 * levelFactor;
                this.shootTimer = rand(2, 4); // Ù…Ø¤Ù‚Øª Ø¥Ø·Ù„Ø§Ù‚ Ù†Ø§Ø± Ø¨Ø·ÙŠØ¡
                this.shootReload = rand(3, 5);
                break;
            default:
                this.speed = 100; this.color = '#fff'; this.hp = 1;
        }
        this.maxHp = this.hp;
        this.score = Math.round(this.score); // ØªÙ‚Ø±ÙŠØ¨ Ø§Ù„Ù†Ù‚Ø§Ø·
    }

    // ÙˆØ¸ÙŠÙØ© Ù„ØªØ­Ø¯ÙŠØ« Ù…ÙˆÙ‚Ø¹ Ø§Ù„Ø¹Ø¯Ùˆ ÙˆØ­Ø±ÙƒØªÙ‡
    update(dt) {
        const dx = player.x - this.x;
        const dy = player.y - this.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        const speedFactor = slowdownTimer > 0 ? 0.5 : 1;
        
        // Ù…Ù†Ø·Ù‚ Ø§Ù„Ø­Ø±ÙƒØ© Ù„Ø¬Ù…ÙŠØ¹ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡ Ù…Ø§ Ø¹Ø¯Ø§ 'chaotic'
        if (this.type !== 'chaotic' && dist > 0) {
            const angle = Math.atan2(dy, dx);
            
            // Shooter ÙŠØ¨Ù‚Ù‰ Ø¹Ù„Ù‰ Ù…Ø³Ø§ÙØ© Ù‚ØµÙŠØ±Ø©
            if (this.type === 'shooter' && dist < 200) {
                this.x += Math.cos(angle) * this.speed * dt * speedFactor * 0.1;
                this.y += Math.sin(angle) * this.speed * dt * speedFactor * 0.1;
            } else {
                this.x += Math.cos(angle) * this.speed * dt * speedFactor;
                this.y += Math.sin(angle) * this.speed * dt * speedFactor;
            }
        } else if (this.type === 'chaotic') {
            // Ù…Ù†Ø·Ù‚ Ø§Ù„Ø­Ø±ÙƒØ© Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ù„Ù„Ø¹Ø¯Ùˆ Ø§Ù„ÙÙˆØ¶ÙˆÙŠ
            this.moveTimer -= dt;
            if (this.moveTimer <= 0) {
                // ØªØºÙŠÙŠØ± Ø§Ù„Ø§ØªØ¬Ø§Ù‡ ÙƒÙ„ 0.5 Ø¥Ù„Ù‰ 1.5 Ø«Ø§Ù†ÙŠØ©
                this.angle = rand(0, Math.PI * 2);
                this.moveTimer = rand(0.5, 1.5); 
            }
            
            // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ø­Ø±ÙƒØ© Ø¨Ù†Ø§Ø¡Ù‹ Ø¹Ù„Ù‰ Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠØ©
            this.x += Math.cos(this.angle) * this.speed * dt * speedFactor;
            this.y += Math.sin(this.angle) * this.speed * dt * speedFactor;
            
            // Ø¥Ø¨Ù‚Ø§Ø¡ Ø§Ù„Ø¹Ø¯Ùˆ Ø§Ù„ÙÙˆØ¶ÙˆÙŠ Ø¶Ù…Ù† Ø­Ø¯ÙˆØ¯ Ø§Ù„Ù„Ø¹Ø¨
            this.x = clamp(this.x, -PADDING + this.r, W + PADDING - this.r);
            this.y = clamp(this.y, -PADDING + this.r, H + PADDING - this.r);
        }

        // Ù…Ù†Ø·Ù‚ Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù†Ø§Ø±
        if ((this.type === 'shooter' || this.type === 'chaotic')) {
            this.shootTimer -= dt;
            if (this.shootTimer <= 0) {
                if (this.type === 'shooter') {
                    enemyShoot(this.x, this.y, player.x, player.y);
                    this.shootTimer = this.shootReload; 
                } else if (this.type === 'chaotic') {
                    // Ø¥Ø·Ù„Ø§Ù‚ Ù†Ø§Ø± Ø¹Ø´ÙˆØ§Ø¦ÙŠ Ø¨Ù€ 4 Ø±ØµØ§ØµØ§Øª Ù„Ù„Ù€ Chaotic
                    for (let i = 0; i < 3; i++) {
                        const randomAngle = rand(0, Math.PI * 2); 
                        // Ù†Ù…Ø±Ø± Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø¹Ø´ÙˆØ§Ø¦ÙŠØ© Ø¨Ø¯Ù„Ø§Ù‹ Ù…Ù† Ø¥Ø­Ø¯Ø§Ø«ÙŠØ§Øª Ø§Ù„Ù„Ø§Ø¹Ø¨
                        enemyShoot(this.x, this.y, null, null, randomAngle); 
                    }
                    this.shootTimer = this.shootReload; 
                }
            }
        }
    }
}
// ===================================

    // === Ù†Ø¸Ø§Ù… Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø§Ù„Ù…Ø­Ø³Ù‘Ù† ===
    function checkCollisions() {
        // Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø¨ÙŠÙ† Ø§Ù„Ø±ØµØ§Øµ ÙˆØ§Ù„Ø£Ø¹Ø¯Ø§Ø¡ (Ø£ÙƒØ«Ø± ÙƒÙØ§Ø¡Ø©)
        for (let j = bullets.length - 1; j >= 0; j--) {
            const bullet = bullets[j];
            
            if (bullet.fromEnemy) {
                // Ø±ØµØ§Øµ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡ Ù…Ø¹ Ø§Ù„Ù„Ø§Ø¹Ø¨
                if (dist(bullet, player) < bullet.r + player.r) {
                    bullets.splice(j, 1);
                    if (player.shieldTimer <= 0) {
                        player.hp = clamp(player.hp - 1, 0, player.maxHp);
                        spawnParticles(player.x, player.y, '#ef476f', 28);
                        safePlayBeep(80, 0.6, 'sine', 0.08);
                        
                        if (player.hp <= 0) {
                            gameOver = true;
                            running = false;
                        }
                    } else {
                        safePlayBeep(120, 0.2, 'sine', 0.08);
                    }
                    continue;
                }
            } else {
                // Ø±ØµØ§Øµ Ø§Ù„Ù„Ø§Ø¹Ø¨ Ù…Ø¹ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡
                for (let i = enemies.length - 1; i >= 0; i--) {
                    const enemy = enemies[i];
                    if (dist(bullet, enemy) < bullet.r + enemy.r) {
                        bullets.splice(j, 1);
                        enemy.hp -= bullet.power;
                        spawnParticles(bullet.x, bullet.y, '#ffd166', 10);
                        safePlayBeep(400 + rand(0, 120), 0.06, 'sawtooth', 0.05);
                        
                        if (enemy.hp <= 0) {
                            if (Math.random() < 0.20) spawnPowerup(enemy.x, enemy.y);
                            
                            enemies.splice(i, 1);
                            score += enemy.score;
                            scoreEl.textContent = score;
                            enemiesDefeatedInLevel++;
                            spawnParticles(enemy.x, enemy.y, '#94f', 20);
                            safePlayBeep(1200, 0.08, 'triangle', 0.08);
                            
                            if (score > parseInt(hsEl.textContent || '0')) {
                                // Ù„Ø§ Ù†Ø¯ÙØ¹ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ù‡Ù†Ø§ØŒ ÙÙ‚Ø· ÙÙŠ Ø´Ø§Ø´Ø© Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù„Ø¹Ø¨Ø©
                                // pushScore(score); 
                            }
                        }
                        break;
                    }
                }
            }
        }
        
        // Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ø¨ÙŠÙ† Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡ ÙˆØ§Ù„Ù„Ø§Ø¹Ø¨
        for (let i = enemies.length - 1; i >= 0; i--) {
            const enemy = enemies[i];
            if (dist(enemy, player) < enemy.r + player.r) {
                if (player.shieldTimer <= 0) {
                    player.hp = clamp(player.hp - 1, 0, player.maxHp);
                    spawnParticles(player.x, player.y, '#ef476f', 28);
                    safePlayBeep(80, 0.6, 'sine', 0.08);
                    
                    if (player.hp <= 0) {
                        gameOver = true;
                        running = false;
                    }
                } else {
                    safePlayBeep(120, 0.2, 'sine', 0.08);
                }
                
                spawnParticles(enemy.x, enemy.y, enemy.color, 30);
                enemies.splice(i, 1);
            }
        }
        
        // Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù… Ù…Ø¹ powerups
        for (let i = powerups.length - 1; i >= 0; i--) {
            const p = powerups[i];
            if (dist(p, player) < p.r + player.r) {
                applyPowerup(p.type);
                safePlayBeep(1500, 0.1, 'sine', 0.1);
                powerups.splice(i, 1);
            }
        }
    }

function applyPowerup(type) {
    switch(type) {
        case 'points': score += 1000; break//Ø§Ù„Ù…ÙƒØ§ÙØ£Ø©;
        case 'rapid': rapidFireTimer = 6; break//Ø³Ø±Ø¹Ù‡ Ø§Ù„Ø§Ø·Ù„Ø§Ù‚;
        case 'magnet': player.magnetTimer = 6; break//Ù…ØºÙ†Ø§Ø·ÙŠØ³;
        case 'shield': player.shieldTimer = 4; break//Ø¯Ø±Ø¹;
        case 'health': player.hp = clamp(player.hp + 1, 0, player.maxHp); break;
        case 'slowdown': slowdownTimer = 5; break//Ø¥Ø¨Ø·Ø§Ø¡;
        
        // Ù…Ù†Ø·Ù‚ Ù‚Ù†Ø¨Ù„Ø© Ø§Ù„Ø§Ù†ÙØ¬Ø§Ø±
        case 'nova': 
            enemies.forEach(e => {
                spawnParticles(e.x, e.y, e.color, 25);
                score += e.score; 
            });
            enemies = []; 
            safePlayBeep(2000, 0.2, 'sawtooth', 0.2); 
            break;
    }
    updateHUDIndicators();
}


    // === Ù†Ø¸Ø§Ù… Ø¥Ø¯Ø§Ø±Ø© Ø§Ù„Ù‚ÙˆØ§Ø¦Ù… ===
    function showMenu(menuId) {
        overlay.style.display = 'flex';
        mainMenu.style.display = 'none';
        settingsMenu.style.display = 'none';
        scoresMenu.style.display = 'none';
        upgradeMenu.style.display = 'none';
        storeMenu.style.display = 'none'; 
        
        const menu = document.getElementById(menuId);
        if (menu) menu.style.display = 'block';
    }

    // ** ÙˆØ¸ÙŠÙØ© Ø¥ÙŠÙ‚Ø§Ù Ù…Ø¤Ù‚Øª Ù„Ù„Ø¹Ø¨Ø© **
    let wasRunningBeforeSettings = false; // Ø­Ø§Ù„Ø© Ø¬Ø¯ÙŠØ¯Ø© Ù„ØªØªØ¨Ø¹ Ø­Ø§Ù„Ø© Ø§Ù„Ù„Ø¹Ø¨ Ù‚Ø¨Ù„ ÙØªØ­ Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª

    function togglePause() {
        running = !running;
        if (running) {
            last = performance.now();
            animationFrameId = requestAnimationFrame(loop);
        } else {
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }
        }
    }

    // === Ù…Ø¹Ø§Ù„Ø¬Ø© Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù…ØªØ¬Ø± (Ø¬Ø¯ÙŠØ¯) ===
    function setupStoreMenu() {
        const list = document.getElementById('store-items-list');
        list.innerHTML = '';
        // ØªØ­Ø¯ÙŠØ« Ø¹Ø±Ø¶ Ø§Ù„Ù†Ù‚Ø§Ø· Ø§Ù„Ø¯Ø§Ø¦Ù…Ø©
        document.getElementById('current-permanent-score-store').textContent = permanentScore; 

        const storeItems = [
            { key: 'fireRate', title: 'Ù…Ø¹Ø¯Ù„ Ø§Ù„Ø§Ø·Ù„Ø§Ù‚', desc: '' },
            { key: 'speed', title: 'Ø³Ø±Ø¹Ø© Ø§Ù„Ø­Ø±ÙƒØ©', desc: '' },
            { key: 'power', title: 'Ù‚ÙˆØ© Ø§Ù„Ø±ØµØ§Øµ', desc: '' },
            { key: 'maxHp', title: 'Ù‚Ù„Ø¨ Ø¥Ø¶Ø§ÙÙŠ â¤ï¸', desc: '' },
            { key: 'doubleShot', title: 'Ø±ØµØ§Øµ Ø¥Ø¶Ø§ÙÙŠ', desc: '' } // ØªÙ… ØªØºÙŠÙŠØ± Ø§Ù„ÙˆØµÙ
        ];

        storeItems.forEach(item => {
            const level = permanentStore.upgrades[item.key];
            const max = permanentStore.MAX_LEVELS[item.key];
            const cost = permanentStore.getCost(item.key);
            const sellPrice = permanentStore.getSellPrice(item.key);
            const canBuy = permanentStore.canBuy(item.key, permanentScore);
            const canSell = level > 0;

            const itemDiv = document.createElement('div');
            itemDiv.className = 'store-item';
            
            const infoDiv = document.createElement('div');
            infoDiv.className = 'store-item-info';
            infoDiv.innerHTML = `
                <div class="store-item-title">${item.title}</div>
                <div class="muted">${item.desc}</div>
                <div>Ø§Ù„Ù…Ø³ØªÙˆÙ‰: ${level} / ${max}</div>
            `;
            
            // Ø­Ø§ÙˆÙŠØ© Ù„Ù„Ø£Ø²Ø±Ø§Ø±
            const buttonContainer = document.createElement('div');
            buttonContainer.style.display = 'flex';
            buttonContainer.style.gap = '5px';

            // Ø²Ø± Ø§Ù„Ø´Ø±Ø§Ø¡
            const buyBtn = document.createElement('button');
            buyBtn.className = 'buy-btn';
            
            if (level >= max) {
                buyBtn.textContent = 'Ø£Ù‚ØµÙ‰ Ù…Ø³ØªÙˆÙ‰ âœ…';
                buyBtn.disabled = true;
            } else {
                buyBtn.textContent = `Ø´Ø±Ø§Ø¡${cost}`;
                buyBtn.disabled = !canBuy;
                buyBtn.addEventListener('click', () => {
                    if (permanentStore.buyUpgrade(item.key)) {
                        setupStoreMenu(); // Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø©
                        safePlayBeep(1800, 0.1, 'square', 0.1); // ØµÙˆØª Ø´Ø±Ø§Ø¡ Ù†Ø§Ø¬Ø­
                    } else {
                         safePlayBeep(100, 0.1, 'sine', 0.1); // ØµÙˆØª ÙØ´Ù„ Ø§Ù„Ø´Ø±Ø§Ø¡
                    }
                });
            }
            
            // Ø²Ø± Ø§Ù„Ø¨ÙŠØ¹
            const sellBtn = document.createElement('button');
            sellBtn.className = 'sell-btn';
            sellBtn.textContent = `Ø¨ÙŠØ¹${sellPrice}`;
            sellBtn.disabled = !canSell;
            sellBtn.addEventListener('click', () => {
                if (permanentStore.sellUpgrade(item.key)) {
                    setupStoreMenu(); // Ø¥Ø¹Ø§Ø¯Ø© Ø¨Ù†Ø§Ø¡ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ù„ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø­Ø§Ù„Ø©
                    safePlayBeep(800, 0.1, 'triangle', 0.1); // ØµÙˆØª Ø¨ÙŠØ¹
                }
            });

            buttonContainer.appendChild(buyBtn);
            buttonContainer.appendChild(sellBtn);
            
            itemDiv.appendChild(infoDiv);
            itemDiv.appendChild(buttonContainer);
            list.appendChild(itemDiv);
        });
    }


    // === Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù…Ø­Ø³Ù†Ø© ===
    startGameBtn.addEventListener('click', () => {
        resetGame();
        overlay.style.display = 'none';
        inMenu = false;
        healthBar.style.display = 'block';
        hudIndicators.style.display = 'block';
    });

    // ** ØªØ¹Ø¯ÙŠÙ„ Ù…Ø¹Ø§Ù„Ø¬Ø© Ø²Ø± Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª ÙÙŠ Ø§Ù„Ù€ Header (Ø§Ù„Ù…ØªØ·Ù„ÙØ¨ Ø±Ù‚Ù… 5) **
    settingsBtn.addEventListener('click', () => { 
        if(running) {
            wasRunningBeforeSettings = true;
            togglePause(); // Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù„Ø¹Ø¨Ø© Ù…Ø¤Ù‚ØªØ§Ù‹
        } else {
            wasRunningBeforeSettings = false;
        }
        showMenu('settings-menu'); 
    });
    settingsMenuBtn.addEventListener('click', () => { showMenu('settings-menu'); });
    
    closeSettingsBtn.addEventListener('click', () => {
        overlay.style.display = inMenu ? 'flex' : 'none';
        if (inMenu) showMenu('main-menu');
        else if(wasRunningBeforeSettings) togglePause(); // Ø§Ø³ØªØ¦Ù†Ø§Ù Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ØªØ¹Ù…Ù„ Ù‚Ø¨Ù„ ÙØªØ­ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
        else if(running) overlay.style.display = 'none';
    });

    scoresMenuBtn.addEventListener('click', () => {
        const scoreList = document.getElementById('score-list');
        const arr = loadHighScores();
        scoreList.innerHTML = arr.map((s, i) => 
            `<li>${i + 1}. <b>${s.score}</b> - ${new Date(s.date).toLocaleDateString('ar-EG')} - Ø§Ù„Ù…Ø³ØªÙˆÙ‰ ${s.level}</li>`
        ).join('');
        showMenu('scores-menu');
    });

    closeScoresBtn.addEventListener('click', () => { showMenu('main-menu'); });
    
    storeMenuBtn.addEventListener('click', () => { // Ø²Ø± Ø§Ù„Ù…ØªØ¬Ø±
        setupStoreMenu();
        showMenu('store-menu');
    });
    
    closeStoreBtn.addEventListener('click', () => { showMenu('main-menu'); }); // Ø¥ØºÙ„Ø§Ù‚ Ø§Ù„Ù…ØªØ¬Ø±

    // Ø¬Ø¹Ù„ Ø²Ø± Ø§Ù„Ù…ØªØ¬Ø± ÙÙŠ "Ø§Ù„Ù€ Header" ÙŠØ¹Ù…Ù„
    headerStoreBtn.addEventListener('click', () => {
        // Ù„Ø§ Ù†Ø­ØªØ§Ø¬ Ù„Ø¥ÙŠÙ‚Ø§Ù Ø§Ù„Ù„Ø¹Ø¨Ø© Ø¹Ù†Ø¯ ÙØªØ­ Ø§Ù„Ù…ØªØ¬Ø±
        setupStoreMenu();
        showMenu('store-menu');
    });

    // Ù†Ø¸Ø§Ù… Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ© (ØªÙ… Ø­Ø°Ù Ø§Ù„Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬)
    upgradeFireRateBtn.addEventListener('click', () => { 
        player.upgrades.fireRate++; 
        startNextLevel(); 
    });
    upgradeSpeedBtn.addEventListener('click', () => { 
        player.upgrades.speed++; 
        startNextLevel(); 
    });
    upgradeBulletPowerBtn.addEventListener('click', () => { 
        player.upgrades.bulletPower++; 
        startNextLevel(); 
    });

    function resetPlayerUpgrades() {
        // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ© ÙÙ‚Ø·
        player.upgrades = { fireRate: 0, speed: 0, bulletPower: 0 };
        // Ø³ÙŠØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© ÙˆØ§Ù„Ø«Ø§Ø¨ØªØ© Ù…Ù† Ø§Ù„Ù…ØªØ¬Ø± ÙÙŠ Ø¯Ø§Ù„Ø© resetGame
    }

    // Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª
    document.getElementById('difficulty').addEventListener('change', e => { 
        state.difficulty = e.target.value; 
        applyDifficulty(); 
    });
    
    document.getElementById('soundToggle').addEventListener('change', e => { 
        state.sound = e.target.checked; 
    });
    
    document.getElementById('musicToggle').addEventListener('change', e => { 
        state.music = e.target.checked; 
        if (state.music && running) startMusic(); 
        else stopMusic(); 
    });
    
    document.getElementById('sensitivity').addEventListener('input', e => { 
        state.sensitivity = parseFloat(e.target.value); 
    });
    
    restartBtn.addEventListener('click', () => { resetGame(); });

    // === Ù…Ø¹Ø§Ù„Ø¬Ø© Ø§Ù„Ø¥Ø¯Ø®Ø§Ù„ Ø§Ù„Ù…Ø­Ø³Ù†Ø© (Ù†Ø¸Ø§Ù… Ø§Ù„Ù„Ù…Ø³ ÙˆØ§Ù„Ù…Ø§ÙˆØ³ ÙˆÙ„ÙˆØ­Ø© Ø§Ù„Ù…ÙØ§ØªÙŠØ­) ===
    
    window.addEventListener('keydown', e => {
        const key = e.key.toLowerCase();
        keys[key] = true;
        
        if (key === 'p') togglePause();
        if (key === 'r' && gameOver) resetGame();
        if (key === 'escape' && running) togglePause();
    });
    
    window.addEventListener('keyup', e => {
        keys[e.key.toLowerCase()] = false;
    });

    // Ø¥Ø¯Ø§Ø±Ø© ÙÙ‚Ø¯Ø§Ù† Ø§Ù„ØªØ±ÙƒÙŠØ²
    window.addEventListener('blur', () => {
        if (running && !gameOver) {
            togglePause();
        }
    });

    // === Ù†Ø¸Ø§Ù… Ø§Ù„Ù„Ù…Ø³ Ø§Ù„Ù…Ø­Ø³Ù‘Ù† (ØªÙ… Ø§Ù„Ø§Ø­ØªÙØ§Ø¸ Ø¨Ø§Ù„ÙƒÙˆØ¯ ÙƒÙ…Ø§ Ù‡Ùˆ) ===
    let touchBounds = { left: null, right: null };
    
    function updateTouchBounds() {
        touchBounds = {
            left: leftJoystickEl.getBoundingClientRect(),
            right: rightJoystickEl.getBoundingClientRect()
        };
    }

    window.addEventListener('touchstart', handleTouchStart);
    window.addEventListener('touchmove', handleTouchMove);
    window.addEventListener('touchend', handleTouchEnd);
    window.addEventListener('touchcancel', handleTouchEnd);
    
    // ØªØ­Ø¯ÙŠØ« Ø­Ø¯ÙˆØ¯ Ø§Ù„Ù„Ù…Ø³ Ø¹Ù†Ø¯ ØªØºÙŠÙŠØ± Ø§Ù„Ø­Ø¬Ù…
    window.addEventListener('resize', updateTouchBounds);
    updateTouchBounds();

    function handleTouchStart(e) {
        if (audioCtx && audioCtx.state === 'suspended') {
            audioCtx.resume().catch(() => {});
        }
        
        updateTouchBounds();
        
        for (const touch of e.changedTouches) {
            const { clientX, clientY, identifier } = touch;
            
            if (!leftJoystick.active && isInBounds(clientX, clientY, touchBounds.left)) {
                activateJoystick(leftJoystick, leftJoystickEl, leftJoystickStickEl, clientX, clientY, identifier);
            } else if (!rightJoystick.active && isInBounds(clientX, clientY, touchBounds.right)) {
                activateJoystick(rightJoystick, rightJoystickEl, rightJoystickStickEl, clientX, clientY, identifier);
            }
        }
    }

    function isInBounds(x, y, bounds) {
        return x >= bounds.left && x <= bounds.right && y >= bounds.top && y <= bounds.bottom;
    }

    function activateJoystick(joystick, element, stick, x, y, id) {
        joystick.active = true;
        joystick.startX = x;
        joystick.startY = y;
        joystick.touchId = id;
        joystick.dx = joystick.dy = 0;
        element.classList.add('active');
    }

    function handleTouchMove(e) {
        for (const touch of e.changedTouches) {
            const { clientX, clientY, identifier } = touch;
            
            if (leftJoystick.active && leftJoystick.touchId === identifier) {
                updateJoystickPosition(leftJoystick, leftJoystickStickEl, clientX, clientY);
            } else if (rightJoystick.active && rightJoystick.touchId === identifier) {
                updateJoystickPosition(rightJoystick, rightJoystickStickEl, clientX, clientY);
            }
        }
    }

    function updateJoystickPosition(joystick, stickElement, x, y) {
        const dx = x - joystick.startX;
        const dy = y - joystick.startY;
        const dist = Math.hypot(dx, dy);
        const maxDist = joystick.maxDist;
        
        if (dist > maxDist) {
            joystick.dx = (dx / dist) * maxDist;
            joystick.dy = (dy / dist) * maxDist;
        } else {
            joystick.dx = dx;
            joystick.dy = dy;
        }
        
        stickElement.style.transform = `translate(${joystick.dx}px, ${joystick.dy}px)`;
    }

    function handleTouchEnd(e) {
        for (const touch of e.changedTouches) {
            const { identifier } = touch;
            
            if (leftJoystick.active && leftJoystick.touchId === identifier) {
                deactivateJoystick(leftJoystick, leftJoystickEl, leftJoystickStickEl);
            } else if (rightJoystick.active && rightJoystick.touchId === identifier) {
                deactivateJoystick(rightJoystick, rightJoystickEl, rightJoystickStickEl);
            }
        }
    }

    function deactivateJoystick(joystick, element, stickElement) {
        joystick.active = false;
        joystick.dx = joystick.dy = 0;
        joystick.touchId = null;
        stickElement.style.transform = 'translate(0, 0)';
        element.classList.remove('active');
    }

    // Ø£Ø­Ø¯Ø§Ø« Ø§Ù„Ù…Ø§ÙˆØ³
    canvas.addEventListener('mousemove', e => {
        const rect = canvas.getBoundingClientRect();
        mouse.x = (e.clientX - rect.left) * (canvas.width / rect.width);
        mouse.y = (e.clientY - rect.top) * (canvas.height / rect.height);
    });
    
    canvas.addEventListener('mousedown', e => {
        mouse.down = true;
        if (audioCtx && audioCtx.state === 'suspended') {
            audioCtx.resume().catch(() => {});
        }
    });
    
    canvas.addEventListener('mouseup', e => { 
        mouse.down = false; 
    });

    // === ÙˆØ¸Ø§Ø¦Ù Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© Ø§Ù„Ù…Ø­Ø³Ù†Ø© ===
    function shoot(fromX, fromY, tx, ty) {
    // Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø£ØµÙ„ÙŠØ© Ù„Ù„Ø±ØµØ§ØµØ© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©
    const ang = Math.atan2(ty - fromY, tx - fromX); 
    const bulletSpeed = 520 * state.sensitivity;
    
    const newBullet = { 
        x: fromX, y: fromY, // Ø§Ù„Ù…ÙˆÙ‚Ø¹ Ù‡Ùˆ Ø¯Ø§Ø¦Ù…Ù‹Ø§ Ù…Ø±ÙƒØ² Ø§Ù„Ù„Ø§Ø¹Ø¨
        vx: Math.cos(ang) * bulletSpeed, 
        vy: Math.sin(ang) * bulletSpeed, 
        r: 4,//Ø­Ø¬Ù… Ø§Ù„Ø±ØµØ§Øµ
        life: 1.6, 
        power: player.bulletPower,
        fromEnemy: false
    };
    
    // Ø¹Ø¯Ø¯ Ø§Ù„Ø±ØµØ§ØµØ§Øª Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ© Ù‡Ùˆ Ù…Ø³ØªÙˆÙ‰ Ø§Ù„ØªØ±Ù‚ÙŠØ© Ø§Ù„Ø¯Ø§Ø¦Ù…Ø©
    const extraBullets = player.doubleShotPermanentLevel; 
    
    if (extraBullets > 0) {
        // Ù‚ÙŠÙ…Ø© Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø§Ù†ÙØ±Ø§Ø¬ Ù„ÙƒÙ„ Ø·Ù„Ù‚Ø© Ø¥Ø¶Ø§ÙÙŠØ©
        const ANGLE_SPREAD = 0.1; // ÙŠÙ…ÙƒÙ†Ùƒ ØªØºÙŠÙŠØ± Ù‡Ø°Ø§ Ø§Ù„Ø±Ù‚Ù… (0.15 Ø±Ø§Ø¯ÙŠØ§Ù†)
        
        // Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ø±ØµØ§ØµØ© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© (ØªØ®Ø±Ø¬ Ø¯Ø§Ø¦Ù…Ù‹Ø§ Ø¨Ø´ÙƒÙ„ Ù…Ø³ØªÙ‚ÙŠÙ…)
        bullets.push(newBullet);
        
        // Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ø±ØµØ§ØµØ§Øª Ø§Ù„Ø¥Ø¶Ø§ÙÙŠØ©
        for (let i = 1; i <= extraBullets; i++) {
            // 1. Ø­Ø³Ø§Ø¨ Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„Ø·Ù„Ù‚Ø§Øª Ø§Ù„ØªÙŠ ØªÙ†Ø·Ù„Ù‚ Ù„Ù„ÙŠÙ…ÙŠÙ† (Ø¨Ø´ÙƒÙ„ Ø£ÙˆØ³Ø¹)
            const rightAngle = ang + ANGLE_SPREAD * i; 
            
            // 2. Ø¥Ø·Ù„Ø§Ù‚ Ø±ØµØ§ØµØ© Ø§Ù„ÙŠÙ…ÙŠÙ† Ù…Ù† Ø§Ù„Ù…Ø±ÙƒØ² (fromX, fromY) Ø¨Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
            bullets.push({ 
                ...newBullet, 
                vx: Math.cos(rightAngle) * bulletSpeed, 
                vy: Math.sin(rightAngle) * bulletSpeed 
            });
            
            // 3. Ø­Ø³Ø§Ø¨ Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø© Ù„Ù„Ø·Ù„Ù‚Ø§Øª Ø§Ù„ØªÙŠ ØªÙ†Ø·Ù„Ù‚ Ù„Ù„ÙŠØ³Ø§Ø± (Ø¨Ø´ÙƒÙ„ Ø£ÙˆØ³Ø¹)
            const leftAngle = ang - ANGLE_SPREAD * i;
            
            // 4. Ø¥Ø·Ù„Ø§Ù‚ Ø±ØµØ§ØµØ© Ø§Ù„ÙŠØ³Ø§Ø± Ù…Ù† Ø§Ù„Ù…Ø±ÙƒØ² (fromX, fromY) Ø¨Ø§Ù„Ø²Ø§ÙˆÙŠØ© Ø§Ù„Ø¬Ø¯ÙŠØ¯Ø©
            bullets.push({ 
                ...newBullet, 
                vx: Math.cos(leftAngle) * bulletSpeed, 
                vy: Math.sin(leftAngle) * bulletSpeed 
            });
        }
        
    } else if (player.upgrades.doubleShot) { 
        // ... (ÙƒÙˆØ¯ Ø§Ù„ØªØ±Ù‚ÙŠØ© Ø§Ù„Ù…Ø¤Ù‚ØªØ© ÙŠØ¨Ù‚Ù‰ ÙƒÙ…Ø§ Ù‡Ùˆ Ø£Ùˆ ÙŠØªÙ… ØªØ¹Ø¯ÙŠÙ„Ù‡ Ø¨Ù†ÙØ³ Ø§Ù„Ø·Ø±ÙŠÙ‚Ø©) ...
        bullets.push(newBullet); // Ù†Ø·Ù„Ù‚ Ø±ØµØ§ØµØ© ÙˆØ§Ø­Ø¯Ø© ÙÙ‚Ø· Ø¥Ø°Ø§ ÙƒØ§Ù†Øª ØªØ±Ù‚ÙŠØ© Ù…Ø¤Ù‚ØªØ©
    } else {
        bullets.push(newBullet);
    }
    
    safePlayBeep(900 + rand(0, 60), 0.03, 'square', 0.06);
}


    function spawnEnemy() {
        const edge = Math.floor(rand(0, 4));
        let ex, ey;
        
        switch(edge) {
            case 0: ex = rand(0, W); ey = -PADDING; break;
            case 1: ex = W + PADDING; ey = rand(0, H); break;
            case 2: ex = rand(0, W); ey = H + PADDING; break;
            default: ex = -PADDING; ey = rand(0, H); break;
        }

        const enemyTypes = ['normal', 'fast', 'tank', 'shooter', 'kamikaze', 'chaotic'];
        const type = enemyTypes[Math.floor(rand(0, enemyTypes.length))];
        
        const enemy = new Enemy(ex, ey, type, level); 
        enemies.push(enemy);
    }


    function calculateDifficulty() {
        const base = {
            easy: { spawnRate: 1.6, enemyHealth: 0.8, enemySpeed: 0.9 },
            normal: { spawnRate: 1.2, enemyHealth: 1.0, enemySpeed: 1.0 },
            hard: { spawnRate: 0.8, enemyHealth: 1.3, enemySpeed: 1.2 }
        }[state.difficulty] || base.normal;
        
        return base;
    }

    function enemyShoot(fromX, fromY, tx, ty, angle = null) { 
        if (angle === null) {
            const dx = player.x - fromX;
            const dy = player.y - fromY;
            angle = Math.atan2(dy, dx);
        }
        
        const bulletSpeed = 160;
        bullets.push({ 
            x: fromX, y: fromY, 
            vx: Math.cos(angle) * bulletSpeed, 
            vy: Math.sin(angle) * bulletSpeed, 
            r: 5,//Ø­Ø¬Ù… Ø±ØµØ§Øµ Ø§Ù„Ø¹Ø¯Ùˆ
 life: 4, 
            fromEnemy: true, 
            color: '#ff6f91' 
        });
        safePlayBeep(300 + rand(0, 40), 0.04, 'sawtooth', 0.05);
    }


    function spawnParticles(x, y, color, count) {
        for (let i = 0; i < count; i++) {
            particles.push(createParticle(x, y, color));
        }
    }


    function spawnPowerup(x, y) {
        const types = ['points', 'health', 'rapid', 'magnet', 'shield', 'slowdown', 'nova']; 
        const type = types[Math.floor(rand(0, types.length))];
        powerups.push({ x, y, r: 12, type, life: 7 });
    }

    // ØªÙ… Ø¯Ù…Ø¬ Ù…Ù†Ø·Ù‚ Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ© ÙˆØ§Ù„Ø¯Ø§Ø¦Ù…Ø© Ù‡Ù†Ø§
	 function applyUpgrades() {
        // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø¥Ù„Ù‰ Ø§Ù„Ù‚ÙŠÙ… Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ© *Ø¨Ø¹Ø¯* ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª Ø§Ù„Ø¯Ø§Ø¦Ù…Ø©
        player.speed = player.initialSpeed;
        player.reload = player.initialReload;
        player.bulletPower = player.initialBulletPower;
        
        // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ©
        player.reload *= Math.pow(0.8, player.upgrades.fireRate);
        player.speed *= Math.pow(1.1, player.upgrades.speed);
        player.bulletPower += (player.upgrades.bulletPower * 2); 
        
        // (ØªÙ… ØªØ¬Ø§Ù‡Ù„ ØªØ±Ù‚ÙŠØ© Ø§Ù„Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬ Ø§Ù„Ù…Ø¤Ù‚ØªØ©)
    }


    function showUpgradeMenu() {
        // ÙÙŠ Ù†Ù…Ø· Ø§Ù„Ù„Ø¹Ø¨ Ø§Ù„Ù…Ø³ØªÙ…Ø±ØŒ Ù†ØªÙŠØ­ ÙƒÙ„ Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ© ÙÙŠ ÙƒÙ„ Ù…Ø±Ø©
        [upgradeFireRateBtn, upgradeSpeedBtn, upgradeBulletPowerBtn] // ØªÙ… Ø­Ø°Ù Ø§Ù„Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù…Ø²Ø¯ÙˆØ¬ Ø§Ù„Ù…Ø¤Ù‚Øª
            .forEach(btn => btn.style.display = 'block');
        
        showMenu('upgrade-menu');
    }

    function updateHUDIndicators() {
        // ÙŠØ¬Ø¨ Ø£Ù† Ù†Ø³ØªØ®Ø¯Ù… (player.doubleShotPermanentLevel > 0) Ø¥Ø°Ø§ Ø£Ø±Ø¯Ù†Ø§ Ù…Ø¤Ø´Ø±Ù‹Ø§ Ù„Ù„Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ø¯Ø§Ø¦Ù…
        // Ù„ÙƒÙ†Ù†Ø§ Ø³Ù†Ø³ØªØ®Ø¯Ù… Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ© ÙÙ‚Ø· Ø­Ø§Ù„ÙŠØ§Ù‹ (Ø¹Ø¯Ø§ Ø§Ù„Ø³Ø±Ø¹Ø©)
        const indicators = {
            'rapid-indicator': rapidFireTimer > 0,
            'shield-indicator': player.shieldTimer > 0,
            'magnet-indicator': player.magnetTimer > 0,
            'slowdown-indicator': slowdownTimer > 0,
            // Ù†Ø¹Ø±Ø¶ Ù…Ø¤Ø´Ø± Ø§Ù„Ø³Ø±Ø¹Ø© Ø¥Ø°Ø§ ÙƒØ§Ù† Ù‡Ù†Ø§Ùƒ Ø£ÙŠ ØªØ±Ù‚ÙŠØ© Ø¯Ø§Ø¦Ù…Ø© Ø£Ùˆ Ù…Ø¤Ù‚ØªØ©
            'speed-indicator': player.upgrades.speed > 0 || permanentStore.upgrades.speed > 0
        };
        
        Object.entries(indicators).forEach(([id, visible]) => {
            document.getElementById(id).style.display = visible ? 'block' : 'none';
        });
        
        // ØªØ­Ø¯ÙŠØ« Ø´Ø±ÙŠØ· Ø§Ù„Ø­ÙŠØ§Ø©
        if (healthFill) {
            const percent = (player.hp / player.maxHp) * 100;
            healthFill.style.width = percent + '%';
            healthFill.style.background = percent > 50 ? '#00ff00' : percent > 25 ? '#ffff00' : '#ff0000';
        }
        // ØªØ­Ø¯ÙŠØ« Ø¹Ù†ØµØ± Ø§Ù„Ù†Øµ Ø§Ù„Ø°ÙŠ ÙŠØ¹Ø±Ø¶ Ø¹Ø¯Ø¯ Ø§Ù„Ù‚Ù„ÙˆØ¨ ÙÙŠ Ø§Ù„ÙˆØ§Ø¬Ù‡Ø© (Ø¥Ù† ÙˆÙØ¬Ø¯)
const healthCountEl = document.getElementById('health-count');
if (healthCountEl) healthCountEl.textContent = player.hp;
    }

    // === Ø§Ù„Ø­Ù„Ù‚Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø§Ù„Ù…Ø­Ø³Ù†Ø© ===
    let last = performance.now();
    
    function loop(ts) {
        if (!running) {
            last = ts;
            animationFrameId = requestAnimationFrame(loop);
            return;
        }
        
        const dt = Math.min((ts - last) / 1000, 0.1); 
        last = ts;
        elapsed += dt;

        // ØªØ­Ø¯ÙŠØ« Ø§Ù„ÙƒØ§Ù…ÙŠØ±Ø§
        camera.x = player.x - W / 2;
        camera.y = player.y - H / 2;

        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ù…Ø¤Ù‚ØªØ§Øª
        if (rapidFireTimer > 0) rapidFireTimer -= dt;
        if (player.shieldTimer > 0) player.shieldTimer -= dt;
        if (player.magnetTimer > 0) player.magnetTimer -= dt;
        if (slowdownTimer > 0) slowdownTimer -= dt;
        
        // Ø­Ø±ÙƒØ© Ø§Ù„Ù„Ø§Ø¹Ø¨
        if (leftJoystick.active && (leftJoystick.dx !== 0 || leftJoystick.dy !== 0)) {
            const angle = Math.atan2(leftJoystick.dy, leftJoystick.dx);
            const currentSpeed = player.speed * dt;
            player.x += Math.cos(angle) * currentSpeed;
            player.y += Math.sin(angle) * currentSpeed;
        } else {
            let vx = 0, vy = 0;
            if (keys['arrowright'] || keys['d']) vx += 1;
            if (keys['arrowleft'] || keys['a']) vx -= 1;
            if (keys['arrowdown'] || keys['s']) vy += 1;
            if (keys['arrowup'] || keys['w']) vy -= 1;
        
            if (vx !== 0 || vy !== 0) {
                const angle = Math.atan2(vy, vx);
                const currentSpeed = player.speed * dt;
                player.x += Math.cos(angle) * currentSpeed;
                player.y += Math.sin(angle) * currentSpeed;
            }
        }

        // Ø­Ø¯ÙˆØ¯ Ø§Ù„Ø¹Ø§Ù„Ù…
        const worldW = W + PADDING * 2;
        const worldH = H + PADDING * 2;
        player.x = clamp(player.x, -PADDING + player.r, W + PADDING - player.r);
        player.y = clamp(player.y, -PADDING + player.r, H + PADDING - player.r);
        
        // ØªÙ‚Ø¯Ù… Ø§Ù„Ù…Ø³ØªÙˆÙ‰ - Ø§Ù„Ù…Ø³ØªÙˆÙŠØ§Øª Ø§Ù„Ù…Ø³ØªÙ…Ø±Ø©
        enemiesPerLevel = 25 + (level - 1) * 5;
            
        if (enemiesDefeatedInLevel >= enemiesPerLevel) {
            running = false;
            showUpgradeMenu(); // ØªØ±Ù‚ÙŠØ© Ù†Ù‡Ø§ÙŠØ© Ø§Ù„Ù…Ø³ØªÙˆÙ‰ Ø§Ù„Ù…Ø¤Ù‚ØªØ©
            return;
        }
// Ø¥Ø·Ù„Ø§Ù‚ Ø§Ù„Ù†Ø§Ø±
player.reloadTimer -= dt;
const currentReload = rapidFireTimer > 0 ? player.reload / 2 : player.reload;

// Ù„Ùˆ Ø§Ø³ØªØ®Ø¯Ù… Ø§Ù„Ù„Ø§Ø¹Ø¨ Ø¯Ø§Ø¦Ø±Ø© Ø§Ù„ØªØµÙˆÙŠØ¨ Ø§Ù„ÙŠÙ…Ù†Ù‰ØŒ ÙÙ†Ø¹Ø·ÙŠÙ‡Ø§ Ø§Ù„Ø£ÙˆÙ„ÙˆÙŠØ©
if (rightJoystick.active && (rightJoystick.dx !== 0 || rightJoystick.dy !== 0)) {
    if (player.reloadTimer <= 0) {
        const ang = Math.atan2(rightJoystick.dy, rightJoystick.dx);
        const tx = player.x + Math.cos(ang) * 100;
        const ty = player.y + Math.sin(ang) * 100;
        shoot(player.x, player.y, tx, ty);
        player.reloadTimer = currentReload;
    }
}
// Ù„Ùˆ Ù„Ù… ÙŠØ³ØªØ®Ø¯Ù… Ø¯Ø§Ø¦Ø±Ø© Ø§Ù„ØªØµÙˆÙŠØ¨ØŒ Ø§ØªØ¨Ø¹ Ø§ØªØ¬Ø§Ù‡ Ø§Ù„Ø­Ø±ÙƒØ©
else if (leftJoystick.active && (leftJoystick.dx !== 0 || leftJoystick.dy !== 0)) {
    if (player.reloadTimer <= 0) {
        const ang = Math.atan2(leftJoystick.dy, leftJoystick.dx);
        const tx = player.x + Math.cos(ang) * 100;
        const ty = player.y + Math.sin(ang) * 100;
        shoot(player.x, player.y, tx, ty);
        player.reloadTimer = currentReload;
    }
}
// Ø¯Ø¹Ù… Ø§Ù„Ù…Ø§ÙˆØ³ ÙÙ‚Ø· Ù„Ùˆ ÙƒØ§Ù† ÙÙŠ Ø§Ù„Ø­Ø§Ø³ÙˆØ¨
else if (mouse.down && player.reloadTimer <= 0) {
    shoot(player.x, player.y, mouse.x + camera.x, mouse.y + camera.y);
    player.reloadTimer = currentReload;
}

        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø±ØµØ§Øµ
        bullets = bullets.filter(b => {
            b.x += b.vx * dt;
            b.y += b.vy * dt;
            b.life -= dt;
            return b.life > 0 && 
                   b.x > -PADDING * 2 && b.x < W + PADDING * 2 && 
                   b.y > -PADDING * 2 && b.y < H + PADDING * 2;
        });

        // ØªÙˆÙ„ÙŠØ¯ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡
        spawnTimer -= dt;
        if (spawnTimer <= 0 && (enemies.length + enemiesDefeatedInLevel < enemiesPerLevel)) {
            const count = Math.min(3 + Math.floor(level / 2), 12); 
            for (let i = 0; i < count; i++) spawnEnemy();
            spawnRate = calculateDifficulty().spawnRate * Math.pow(0.95, level); // Ø²ÙŠØ§Ø¯Ø© ØµØ¹ÙˆØ¨Ø© SpawnRate
            spawnTimer = spawnRate;
        }

        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡
        enemies.forEach(enemy => {
            enemy.update(dt); 
        });

        // Ø¥Ø²Ø§Ù„Ø© Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡ Ø®Ø§Ø±Ø¬ Ø§Ù„Ø­Ø¯ÙˆØ¯
        enemies = enemies.filter(enemy => 
            enemy.x >= -PADDING * 2 && enemy.x <= W + PADDING * 2 && 
            enemy.y >= -PADDING * 2 && enemy.y <= H + PADDING * 2
        );

        // Ø§Ù„ØªØ­Ù‚Ù‚ Ù…Ù† Ø§Ù„Ø§ØµØ·Ø¯Ø§Ù…Ø§Øª
        checkCollisions();

        // ØªØ­Ø¯ÙŠØ« powerups Ù…Ø¹ Ø§Ù„Ù…ØºÙ†Ø§Ø·ÙŠØ³
        powerups.forEach(p => {
            if (player.magnetTimer > 0 && dist(p, player) < 200) {
                const angle = Math.atan2(player.y - p.y, player.x - p.x);
                p.x += Math.cos(angle) * 300 * dt;
                p.y += Math.sin(angle) * 300 * dt;
            }
            p.life -= dt;
        });
        
        powerups = powerups.filter(p => p.life > 0);
            
        // ØªØ­Ø¯ÙŠØ« Ø§Ù„Ø¬Ø³ÙŠÙ…Ø§Øª
        particles.forEach(p => {
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vx *= 0.98;
            p.vy *= 0.98;
            p.life -= dt;
        });
        
        particles = particles.filter(p => p.life > 0);

        // Ø§Ù„Ø±Ø³Ù… ÙˆØ§Ù„ØªØ­Ø¯ÙŠØ«Ø§Øª
        render();
        updateHUDIndicators();
        
        if (!gameOver) {
            animationFrameId = requestAnimationFrame(loop);
        } else {
            showGameOver();
        }
    }

    function resetGame() {
        if (animationFrameId) {
            cancelAnimationFrame(animationFrameId);
        }
        
        fitCanvas();
        cleanup();
        
        
        // **ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª Ø§Ù„Ø¯Ø§Ø¦Ù…Ø© Ù…Ù† Ø§Ù„Ù…ØªØ¬Ø±**
        permanentStore.applyToPlayer(player);
        
        // Ø¥Ø¹Ø§Ø¯Ø© Ø§Ù„ØªØ¹ÙŠÙŠÙ†
        score = 0; // ÙŠØªÙ… Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ù†Ù‚Ø§Ø· Ø§Ù„Ø¬ÙˆÙ„Ø© ÙÙ‚Ø·
        scoreEl.textContent = score;
        player.x = W / 2;
        player.y = H / 2;
        player.hp = player.maxHp;
        resetPlayerUpgrades(); // Ø¥Ø¹Ø§Ø¯Ø© ØªØ¹ÙŠÙŠÙ† Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª Ø§Ù„Ù…Ø¤Ù‚ØªØ© ÙÙ‚Ø·
        running = true;
        gameOver = false;
        level = 1;
        enemiesDefeatedInLevel = 0;
        boss = null;
        rapidFireTimer = 0;
        slowdownTimer = 0;
        survivalMode = false;
        survivalTimer = 0;
        
        last = performance.now();
        applyDifficulty();
        applyUpgrades(); // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª (Ø§Ù„Ø¯Ø§Ø¦Ù…Ø© ÙˆØ§Ù„Ù…Ø¤Ù‚ØªØ©)
        
        if (state.music) startMusic();
        animationFrameId = requestAnimationFrame(loop);
        
        healthBar.style.display = 'block';
        hudIndicators.style.display = 'block';
        updateHUDIndicators();
    }
    
    function cleanup() {
        bullets.length = 0;
        enemies.length = 0;
        particles.length = 0;
        powerups.length = 0;
        particlePool.length = 0;
        bulletPool.length = 0;
    }

    function startNextLevel() {
        level++;
        enemiesDefeatedInLevel = 0;
        cleanup();
        boss = null;
        rapidFireTimer = 0;
        slowdownTimer = 0;
        survivalMode = false;
        survivalTimer = 0;
        
        last = performance.now();
        applyUpgrades(); // ØªØ·Ø¨ÙŠÙ‚ Ø§Ù„ØªØ±Ù‚ÙŠØ§Øª (Ø§Ù„Ø¯Ø§Ø¦Ù…Ø© ÙˆØ§Ù„Ù…Ø¤Ù‚ØªØ©)
        applyDifficulty();
        
        if (state.music) {
            stopMusic();
            startMusic();
        }
        
        overlay.style.display = 'none';
        running = true;
        animationFrameId = requestAnimationFrame(loop);
    }

        function showGameOver() {
        pushScore(score); // Ù†Ø¶Ù…Ù† Ø­ÙØ¸ Ø§Ù„Ù†ØªÙŠØ¬Ø© Ø§Ù„Ø¯Ø§Ø¦Ù…Ø© Ù‚Ø¨Ù„ Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©
        
        // Ø¥Ø¸Ù‡Ø§Ø± Ù„ÙˆØ­Ø© Ø§Ù„ØªØ±Ø§ÙƒØ¨ (Overlay) Ø§Ù„ØªÙŠ ØªØ­Ù…Ù„ ÙƒÙ„ Ø§Ù„Ù‚ÙˆØ§Ø¦Ù…
        overlay.style.display = 'flex';
        
        // Ø¥Ø®ÙØ§Ø¡ Ù…Ø¤Ø´Ø±Ø§Øª Ø§Ù„Ù„Ø¹Ø¨ ÙˆØ´Ø±ÙŠØ· Ø§Ù„Ø­ÙŠØ§Ø©
        healthBar.style.display = 'none';
        hudIndicators.style.display = 'none';
        
        // Ø§Ø³ØªØ®Ø¯Ø§Ù… Ø§Ù„Ø¯Ø§Ù„Ø© showMenu Ù„Ø¹Ø±Ø¶ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø© Ø§Ù„Ø±Ø¦ÙŠØ³ÙŠØ© Ø§Ù„Ù…Ø·Ù„ÙˆØ¨Ø©
        showMenu('main-menu');
        
        // Ø¶Ø¨Ø· Ø­Ø§Ù„Ø© Ø§Ù„Ù„Ø¹Ø¨Ø© ÙƒÙ€ "ÙÙŠ Ø§Ù„Ù‚Ø§Ø¦Ù…Ø©"
        inMenu = true;
    }


    // === Ù†Ø¸Ø§Ù… Ø§Ù„Ø±Ø³Ù… Ø§Ù„Ù…Ø­Ø³Ù‘Ù† ===
    function render() {
        ctx.clearRect(0, 0, W, H);
        ctx.save();
        ctx.translate(-camera.x, -camera.y);

        // Ø§Ù„Ø®Ù„ÙÙŠØ©
        const hue = (level * 12) % 360;
        ctx.fillStyle = `hsl(${hue} 40% 6%)`;
        ctx.fillRect(player.x - W / 2, player.y - H / 2, W, H);
        
        // Ø§Ù„Ø´Ø¨ÙƒØ©
        ctx.save();
        ctx.globalAlpha = 0.04;
        ctx.fillStyle = '#fff';
        for (let x = -PADDING % 40; x < W + PADDING; x += 40) {
            ctx.fillRect(x, -PADDING, 1, H + PADDING * 2);
        }
        for (let y = -PADDING % 40; y < H + PADDING; y += 40) {
            ctx.fillRect(-PADDING, y, W + PADDING * 2, 1);
        }
        ctx.restore();

        // Ø§Ù„Ø­Ø¯ÙˆØ¯
        ctx.save();
        ctx.strokeStyle = 'rgba(255,255,255,0.2)';
        ctx.lineWidth = 3;
        ctx.strokeRect(-PADDING, -PADDING, W + PADDING * 2, H + PADDING * 2);
        ctx.restore();

        // Ø§Ù„Ù„Ø§Ø¹Ø¨
// Ø§Ù„Ù„Ø§Ø¹Ø¨ Ù…Ø¹ ØªÙˆÙ‡Ø¬ Ø®ÙÙŠÙ
ctx.save();
ctx.shadowBlur = 20;
ctx.shadowColor = player.color;
ctx.beginPath();
ctx.arc(player.x, player.y, player.r, 0, Math.PI * 2);
ctx.fillStyle = player.color;
ctx.fill();
ctx.closePath();
        
        if (player.shieldTimer > 0) {
            ctx.beginPath();
            ctx.globalAlpha = 0.4 + Math.sin(elapsed * 10) * 0.1;
            ctx.strokeStyle = '#00aaff';
            ctx.lineWidth = 4;
            ctx.arc(player.x, player.y, player.r + 8, 0, Math.PI * 2);
            ctx.stroke();
            ctx.globalAlpha = 1;
        }
        
        let turretAngle = 0;
        if (rightJoystick.active && (rightJoystick.dx !== 0 || rightJoystick.dy !== 0)) {
            turretAngle = Math.atan2(rightJoystick.dy, rightJoystick.dx);
        } else if (mouse.down) {
            turretAngle = Math.atan2(mouse.y + camera.y - player.y, mouse.x + camera.x - player.x);
        } else if (leftJoystick.active && (leftJoystick.dx !== 0 || leftJoystick.dy !== 0)) {
            turretAngle = Math.atan2(leftJoystick.dy, leftJoystick.dx);
        }
        
        ctx.translate(player.x, player.y);
        ctx.rotate(turretAngle);
        ctx.fillStyle = '#081026';
        ctx.fillRect(8, -8, 10, 16);
        ctx.restore();

        // Ø§Ù„Ø±ØµØ§Øµ
        bullets.forEach(b => {
            ctx.beginPath();
            ctx.fillStyle = b.fromEnemy ? b.color : '#fff';
            ctx.arc(b.x, b.y, b.r, 0, Math.PI * 2);
            ctx.fill();
        });

        // Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡
        enemies.forEach(e => {
            ctx.beginPath();
            ctx.fillStyle = e.color;
            ctx.arc(e.x, e.y, e.r, 0, Math.PI * 2);
            ctx.fill();
            ctx.fillStyle = '#000';
            ctx.font = '12px Tahoma';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(e.hp, e.x, e.y);
        });

        // Powerups
        powerups.forEach(p => {
            ctx.save();
            ctx.globalAlpha = Math.max(0, p.life / 5);
            
            const emojis = {
                points: 'ğŸ’°', rapid: 'ğŸš€', magnet: 'ğŸ§²', 
                shield: 'ğŸ›¡ï¸', health: 'â¤ï¸', slowdown: 'ğŸŒ',
                nova: 'ğŸ’£' 
            };
            
            ctx.fillStyle = 'rgba(255,255,255,0.8)';
            ctx.font = '22px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(emojis[p.type] || 'âœ¨', p.x, p.y + 2);
            ctx.restore();
        });

        // Ø§Ù„Ø¬Ø³ÙŠÙ…Ø§Øª
        particles.forEach(p => {
            ctx.beginPath();
            ctx.globalAlpha = Math.max(0, p.life / 1.2);
            ctx.fillStyle = p.c;
            ctx.arc(p.x, p.y, p.r, 0, Math.PI * 2);
            ctx.fill();
        });
        
        ctx.restore();
// ===== ÙˆØ§Ø¬Ù‡Ø© Ø§Ù„ØªØ­ÙƒÙ… Ù…Ø±ØªØ¨Ø© Ø¨Ø®Ù„ÙÙŠØ§Øª Ø²Ø¬Ø§Ø¬ÙŠØ© Ù…Ø³ØªÙ‚Ù„Ø© =====

// Ø¥Ø¹Ø¯Ø§Ø¯Ø§Øª Ø¹Ø§Ù…Ø©
ctx.textBaseline = 'top';
ctx.textAlign = 'left';
ctx.font = 'bold 16px Tahoma';

// ===== ğŸ’° Ø¹Ø±Ø¶ Ø§Ù„Ù†Ù‚ÙˆØ¯ (Ø£Ø¹Ù„Ù‰ ÙŠÙ…ÙŠÙ†) =====
{
    const text = `ğŸ’°:${score}`;
    ctx.font = 'bold 16px Tahoma';
    const paddingX = 10;
    const paddingY = 5;
    const textWidth = ctx.measureText(text).width;
    const boxWidth = textWidth + paddingX * 2;
    const boxHeight = 26;
    const boxX = W - boxWidth - 1;
    const boxY = 5;

    // Ø®Ù„ÙÙŠØ© Ø²Ø¬Ø§Ø¬ÙŠØ© Ù‚Ø§Ø¨Ù„Ø© Ù„Ù„ØªÙ…Ø¯Ø¯
    ctx.save();
    ctx.fillStyle = 'rgba(20, 15, 40, 0.55)';
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(boxX, boxY, boxWidth, boxHeight, 8);
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    // Ø§Ù„Ù†Øµ Ø¯Ø§Ø®Ù„Ù‡Ø§
    ctx.fillStyle = '#00ff55';
    ctx.textAlign = 'left';
    ctx.fillText(text, boxX + paddingX, boxY + 6);
}

// ===== ğŸ’€ Ø§Ù„Ø£Ø¹Ø¯Ø§Ø¡ (ØªØ­Øª Ø§Ù„Ù†Ù‚ÙˆØ¯ Ù…Ø¨Ø§Ø´Ø±Ø©) =====
{
    const text = `ğŸ’€:${enemiesDefeatedInLevel}/${enemiesPerLevel}`;
    ctx.font = 'bold 14px Tahoma';
    const paddingX = 10;
    const paddingY = 5;
    const textWidth = ctx.measureText(text).width;
    const boxWidth = textWidth + paddingX * 2;
    const boxHeight = 22;
    const boxX = W - boxWidth - 1;
    const boxY = 37;

    ctx.save();
    ctx.fillStyle = 'rgba(20, 25, 40, 0.55)';
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(boxX, boxY, boxWidth, boxHeight, 8);
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    ctx.fillStyle = '#00e0ff';
    ctx.textAlign = 'left';
    ctx.fillText(text, boxX + paddingX, boxY + 5);
}

// ===== ğŸ”¹ Ø§Ù„Ù…Ø³ØªÙˆÙ‰ (Ù…Ù†ØªØµÙ Ø§Ù„Ø´Ø§Ø´Ø© ÙÙŠ Ø§Ù„Ø£Ø¹Ù„Ù‰) =====
{
    const text = `${level}`;
    ctx.font = 'bold 16px Tahoma';
    const textWidth = ctx.measureText(text).width;
    const boxWidth = textWidth + 20;
    const boxHeight = 28;
    const boxX = (W / 2) - (boxWidth / 2);
    const boxY = 5;

    ctx.save();
    ctx.fillStyle = 'rgba(20, 25, 40, 0.55)';
    ctx.strokeStyle = 'rgba(255,255,255,0.2)';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.roundRect(boxX, boxY, boxWidth, boxHeight, 10);
    ctx.fill();
    ctx.stroke();
    ctx.restore();

    ctx.fillStyle = '#ffae00';
    ctx.textAlign = 'center';
    ctx.fillText(text, W / 2, boxY + 7);
}

// ===== âš¡ Ø§Ù„Ù…Ø¤Ù‚ØªØ§Øª ÙˆØ§Ù„Ù‚Ø¯Ø±Ø§Øª (Ø¨Ø§Ù„Ø¬Ù‡Ø© Ø§Ù„ÙŠØ³Ø±Ù‰) =====
{
    ctx.textAlign = 'left';
    ctx.font = 'bold 14px Tahoma';
    const baseX = 15;
    let baseY = 10;

    function drawBuff(icon, value, color) {
        const text = `${icon} ${value.toFixed(1)}s`;
        const textWidth = ctx.measureText(text).width;
        const boxWidth = textWidth + 16;
        const boxHeight = 25;
        const paddingX = 8;
        const boxY = baseY;
        const boxX = baseX;

        // Ø®Ù„ÙÙŠØ© Ø²Ø¬Ø§Ø¬ÙŠØ© ØµØºÙŠØ±Ø©
        ctx.save();
        ctx.fillStyle = 'rgba(20, 25, 40, 0.45)';
        ctx.strokeStyle = 'rgba(255,255,255,0.15)';
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        ctx.roundRect(boxX, boxY, boxWidth, boxHeight, 6);
        ctx.fill();
        ctx.stroke();
        ctx.restore();

        ctx.fillStyle = color;
        ctx.fillText(text, boxX + paddingX, boxY + 5);
        baseY += boxHeight + 6;
    }

    if (player.shieldTimer > 0) drawBuff('ğŸ›¡', player.shieldTimer, '#00e0ff');
    if (player.magnetTimer > 0) drawBuff('ğŸ§²', player.magnetTimer, '#ffffff');
    if (rapidFireTimer > 0) drawBuff('ğŸš€', rapidFireTimer, '#ffd166');
    if (slowdownTimer > 0) drawBuff('ğŸŒ', slowdownTimer, '#ff66ff');
}}
    function applyDifficulty() {
        const difficulty = calculateDifficulty();
        spawnRate = difficulty.spawnRate;
    }

    // === Ø¨Ø¯Ø¡ Ø§Ù„Ù„Ø¹Ø¨Ø© ===
    // (ØªÙ… Ø­Ø°Ù Ù…Ù†Ø·Ù‚ Ø§Ù„Ù€ PWA ÙˆØ§Ù„Ù€ Service Worker Ù„ØªØ±ÙƒÙŠØ² Ø¹Ù„Ù‰ ÙˆØ¸ÙŠÙØ© Ø§Ù„Ù„Ø¹Ø¨Ø© Ø§Ù„Ø£Ø³Ø§Ø³ÙŠØ©)
    
    // Ø§Ù„ØªÙ‡ÙŠØ¦Ø© Ø§Ù„Ù†Ù‡Ø§Ø¦ÙŠØ©
    showMenu('main-menu');
    applyDifficulty();
    updateHSDisplay();
    
    console.log('ğŸ® Ù„Ø¹Ø¨Ø© Ø­Ø§Ù…ÙŠ Ø§Ù„Ù…Ø¯Ø®Ù„ Ø¬Ø§Ù‡Ø²Ø©! ØªÙ… ØªØ·Ø¨ÙŠÙ‚ Ø¬Ù…ÙŠØ¹ Ø§Ù„ØªØ­Ø³ÙŠÙ†Ø§Øª.');
})();

</script>
</body>
</html>
